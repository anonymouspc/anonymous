In file included from main.cpp:1:
In file included from ./specific/ioexec/ioexec.hpp:4:
In file included from /opt/homebrew/include/boost/asio.hpp:32:
In file included from /opt/homebrew/include/boost/asio/basic_datagram_socket.hpp:20:
In file included from /opt/homebrew/include/boost/asio/basic_socket.hpp:30:
/opt/homebrew/include/boost/asio/socket_base.hpp:159:65: error: expected member name or ';' after declaration specifiers
  158 |   typedef boost::asio::detail::socket_option::boolean<
      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  159 |     BOOST_ASIO_OS_DEF(SOL_SOCKET), BOOST_ASIO_OS_DEF(SO_DEBUG)> debug;
      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^
<command line>:1:15: note: expanded from macro 'debug'
    1 | #define debug 1
      |               ^
In file included from main.cpp:1:
./specific/ioexec/ioexec.hpp:54:32: error: use of undeclared identifier 'decay'
   54 |         return operation_state<decay<decltype(recv)>>(std::move(self), std::forward<decltype(recv)>(recv));
      |                                ^
./specific/ioexec/ioexec.hpp:65:34: error: no template named 'function'; did you mean 'std::function'?
   65 |             virtual void start ( function<void(types...)> ) = 0; // function<void(types...)> refers to boost::asio::completion_token.
      |                                  ^~~~~~~~
      |                                  std::function
/opt/homebrew/Cellar/llvm/19.1.7_1/bin/../include/c++/v1/__functional/function.h:90:28: note: 'std::function' declared here
   90 | class _LIBCPP_TEMPLATE_VIS function; // undefined
      |                            ^
In file included from main.cpp:1:
./specific/ioexec/ioexec.hpp:82:26: error: no template named 'function'; did you mean 'std::function'?
   82 |             void start ( function<void(types...)> ) override; // function<void(types...)> refers to boost::asio::completion_token.
      |                          ^~~~~~~~
      |                          std::function
/opt/homebrew/Cellar/llvm/19.1.7_1/bin/../include/c++/v1/__functional/function.h:90:28: note: 'std::function' declared here
   90 | class _LIBCPP_TEMPLATE_VIS function; // undefined
      |                            ^
In file included from main.cpp:1:
./specific/ioexec/ioexec.hpp:103:75: error: no template named 'function'; did you mean 'std::function'?
  103 |     void sender<types...>::async_starter<func_type,arg_types...>::start ( function<void(types...)> completion_token )
      |                                                                           ^~~~~~~~
      |                                                                           std::function
/opt/homebrew/Cellar/llvm/19.1.7_1/bin/../include/c++/v1/__functional/function.h:90:28: note: 'std::function' declared here
   90 | class _LIBCPP_TEMPLATE_VIS function; // undefined
      |                            ^
In file included from main.cpp:1:
./specific/ioexec/ioexec.hpp:180:92: error: use of undeclared identifier 'decay'
  180 |             executor_with_default ( const auto& ex       ) noexcept requires ( not same_as<decay<decltype(ex)>,executor_with_default> and convertible_to<decay<decltype(ex)>,executor_type> );
      |                                                                                            ^
./specific/ioexec/ioexec.hpp:180:154: error: use of undeclared identifier 'decay'
  180 |             executor_with_default ( const auto& ex       ) noexcept requires ( not same_as<decay<decltype(ex)>,executor_with_default> and convertible_to<decay<decltype(ex)>,executor_type> );
      |                                                                                                                                                          ^
./specific/ioexec/ioexec.hpp:193:32: error: use of undeclared identifier 'decay'
  193 |         requires ( not same_as<decay<decltype(ex)>,executor_with_default> and 
      |                                ^
./specific/ioexec/ioexec.hpp:194:32: error: use of undeclared identifier 'decay'
  194 |                 convertible_to<decay<decltype(ex)>,executor_type> )
      |                                ^
./specific/ioexec/ioexec.hpp:205:25: error: no template named 'decay'; did you mean 'std::decay'?
  205 |         return typename decay<decltype(obj)>::
      |                         ^~~~~
      |                         std::decay
/opt/homebrew/Cellar/llvm/19.1.7_1/bin/../include/c++/v1/__type_traits/decay.h:33:8: note: 'std::decay' declared here
   33 | struct decay {
      |        ^
In file included from main.cpp:1:
./specific/ioexec/ioexec.hpp:206:73: error: no template named 'decay'; did you mean 'std::decay'?
  206 |                 template rebind_executor<executor_with_default<typename decay<decltype(obj)>::executor_type>>::other
      |                                                                         ^~~~~
      |                                                                         std::decay
/opt/homebrew/Cellar/llvm/19.1.7_1/bin/../include/c++/v1/__type_traits/decay.h:33:8: note: 'std::decay' declared here
   33 | struct decay {
      |        ^
In file included from main.cpp:1:
./specific/ioexec/ioexec.hpp:22:22: error: deduced type 'void' does not satisfy 'operation_state'
   22 |             stdexec::operation_state auto connect ( stdexec::receiver auto&& );
      |             ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
/opt/homebrew/include/stdexec/__detail/__senders.hpp:161:61: note: in instantiation of function template specialization 'ioexec::sender<boost::system::error_code>::connect<stdexec::__detail::__receiver<stdexec::__any_::__receiver_ref<stdexec::completion_signatures<stdexec::__rcvrs::set_stopped_t (), stdexec::__rcvrs::set_error_t (std::exception_ptr), stdexec::__rcvrs::set_value_t (boost::system::error_code)>, const stdexec::__sync_wait::__env &>, stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, stdexec::__muchar (*)[1]>::__t>' requested here
  161 |     using __member_result_t = decltype(__declval<_Sender>().connect(__declval<_Receiver>()));
      |                                                             ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:411:5: note: in instantiation of template type alias '__member_result_t' requested here
  411 |     using __g = _Fn<_Args...>;
      |     ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:385:3: note: in instantiation of template type alias '__g' requested here
  385 |   using __meval =                  //
      |   ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:489:42: note: in instantiation of template type alias '__meval' requested here
  489 |   concept __mvalid = requires { typename __meval<_Tp, _Args...>; };
      |                                          ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:489:33: note: in instantiation of requirement here
  489 |   concept __mvalid = requires { typename __meval<_Tp, _Args...>; };
      |                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/opt/homebrew/include/stdexec/__detail/__meta.hpp:489:22: note: (skipping 150 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
  489 |   concept __mvalid = requires { typename __meval<_Tp, _Args...>; };
      |                      ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:139:19: note: in instantiation of template type alias '__sync_wait_result_t' requested here
  139 |       using __t = __sync_wait_result_t<_Sender>;
      |                   ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:34:3: note: in instantiation of template class 'stdexec::__sync_wait::__value_tuple_for<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &>' requested here
   34 |   using __t = typename _Tp::__t;
      |   ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:142:5: note: in instantiation of template type alias '__t' requested here
  142 |     using __value_tuple_for_t = __t<__value_tuple_for<_Sender>>;
      |     ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:217:64: note: in instantiation of template type alias '__value_tuple_for_t' requested here
  217 |       auto operator()(_Sender&& __sndr) const -> std::optional<__value_tuple_for_t<_Sender>> {
      |                                                                ^
main.cpp:9:23: note: while substituting deduced template arguments into function template 'operator()' [with _Sender = __call_result_t<__binder_back<__let_t<set_value_t, dependent_domain>, (lambda at main.cpp:7:36)>, __sexpr<(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}, __anon>> &]
    9 |     stdexec::sync_wait(task);
      |                       ^
/opt/homebrew/include/stdexec/__detail/__operation_states.hpp:57:5: note: because 'void' does not satisfy 'destructible'
   57 |     destructible<_Op> &&     //
      |     ^
/opt/homebrew/include/stdexec/__detail/__concepts.hpp:147:26: note: because '__is_nothrow_destructible(void)' evaluated to false
  147 |   concept destructible = __is_nothrow_destructible(_Ty);
      |                          ^
In file included from main.cpp:1:
./specific/ioexec/ioexec.hpp:22:22: error: deduced type 'void' does not satisfy 'operation_state'
   22 |             stdexec::operation_state auto connect ( stdexec::receiver auto&& );
      |             ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
/opt/homebrew/include/stdexec/__detail/__senders.hpp:161:61: note: in instantiation of function template specialization 'ioexec::sender<boost::system::error_code>::connect<stdexec::__detail::__receiver<stdexec::__any_::__receiver_ref<stdexec::completion_signatures<stdexec::__rcvrs::set_stopped_t (), stdexec::__rcvrs::set_error_t (std::exception_ptr), stdexec::__rcvrs::set_value_t (boost::system::error_code)>, stdexec::__sync_wait::__env>, stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, stdexec::__muchar (*)[1]>::__t>' requested here
  161 |     using __member_result_t = decltype(__declval<_Sender>().connect(__declval<_Receiver>()));
      |                                                             ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:411:5: note: in instantiation of template type alias '__member_result_t' requested here
  411 |     using __g = _Fn<_Args...>;
      |     ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:385:3: note: in instantiation of template type alias '__g' requested here
  385 |   using __meval =                  //
      |   ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:489:42: note: in instantiation of template type alias '__meval' requested here
  489 |   concept __mvalid = requires { typename __meval<_Tp, _Args...>; };
      |                                          ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:489:33: note: in instantiation of requirement here
  489 |   concept __mvalid = requires { typename __meval<_Tp, _Args...>; };
      |                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/opt/homebrew/include/stdexec/__detail/__meta.hpp:489:22: note: (skipping 116 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
  489 |   concept __mvalid = requires { typename __meval<_Tp, _Args...>; };
      |                      ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:139:19: note: in instantiation of template type alias '__sync_wait_result_t' requested here
  139 |       using __t = __sync_wait_result_t<_Sender>;
      |                   ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:34:3: note: in instantiation of template class 'stdexec::__sync_wait::__value_tuple_for<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &>' requested here
   34 |   using __t = typename _Tp::__t;
      |   ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:142:5: note: in instantiation of template type alias '__t' requested here
  142 |     using __value_tuple_for_t = __t<__value_tuple_for<_Sender>>;
      |     ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:217:64: note: in instantiation of template type alias '__value_tuple_for_t' requested here
  217 |       auto operator()(_Sender&& __sndr) const -> std::optional<__value_tuple_for_t<_Sender>> {
      |                                                                ^
main.cpp:9:23: note: while substituting deduced template arguments into function template 'operator()' [with _Sender = __call_result_t<__binder_back<__let_t<set_value_t, dependent_domain>, (lambda at main.cpp:7:36)>, __sexpr<(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}, __anon>> &]
    9 |     stdexec::sync_wait(task);
      |                       ^
/opt/homebrew/include/stdexec/__detail/__operation_states.hpp:57:5: note: because 'void' does not satisfy 'destructible'
   57 |     destructible<_Op> &&     //
      |     ^
/opt/homebrew/include/stdexec/__detail/__concepts.hpp:147:26: note: because '__is_nothrow_destructible(void)' evaluated to false
  147 |   concept destructible = __is_nothrow_destructible(_Ty);
      |                          ^
In file included from main.cpp:1:
In file included from ./specific/ioexec/ioexec.hpp:3:
In file included from /opt/homebrew/include/stdexec/execution.hpp:18:
In file included from /opt/homebrew/include/stdexec/__detail/__execution_fwd.hpp:19:
/opt/homebrew/include/stdexec/__detail/__meta.hpp:904:36: error: no matching function for call to object of type 'stdexec::__connect::connect_t'
  904 |   using __call_result_t = decltype(__declval<_Fun>()(__declval<_As>()...));
      |                                    ^~~~~~~~~~~~~~~~~
/opt/homebrew/include/stdexec/__detail/__senders_core.hpp:77:3: note: in instantiation of template type alias '__call_result_t' requested here
   77 |   using connect_result_t = __call_result_t<connect_t, _Sender, _Receiver>;
      |   ^
/opt/homebrew/include/stdexec/__detail/__let.hpp:222:5: note: in instantiation of template type alias 'connect_result_t' requested here
  222 |     using __op_state_t = connect_result_t<
      |     ^
/opt/homebrew/include/stdexec/__detail/__let.hpp:354:7: note: in instantiation of template type alias '__op_state_t' requested here
  354 |       using __f = __op_state_t<
      |       ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:393:3: note: in instantiation of template type alias '__f' requested here
  393 |   using __minvoke =                       //
      |   ^
/opt/homebrew/include/stdexec/__detail/__tuple.hpp:252:5: note: in instantiation of template type alias '__minvoke' requested here
  252 |     using __f = __minvoke<_Fn, _Ts...>;
      |     ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:710:5: note: (skipping 101 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
  710 |     using __f = typename __muncurry_<_Tp>::template __f<_Fn>;
      |     ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:139:19: note: in instantiation of template type alias '__sync_wait_result_t' requested here
  139 |       using __t = __sync_wait_result_t<_Sender>;
      |                   ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:34:3: note: in instantiation of template class 'stdexec::__sync_wait::__value_tuple_for<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &>' requested here
   34 |   using __t = typename _Tp::__t;
      |   ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:142:5: note: in instantiation of template type alias '__t' requested here
  142 |     using __value_tuple_for_t = __t<__value_tuple_for<_Sender>>;
      |     ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:217:64: note: in instantiation of template type alias '__value_tuple_for_t' requested here
  217 |       auto operator()(_Sender&& __sndr) const -> std::optional<__value_tuple_for_t<_Sender>> {
      |                                                                ^
main.cpp:9:23: note: while substituting deduced template arguments into function template 'operator()' [with _Sender = __call_result_t<__binder_back<__let_t<set_value_t, dependent_domain>, (lambda at main.cpp:7:36)>, __sexpr<(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}, __anon>> &]
    9 |     stdexec::sync_wait(task);
      |                       ^
/opt/homebrew/include/stdexec/__detail/__senders.hpp:257:12: note: candidate template ignored: substitution failure [with _Sender = stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, _Receiver = stdexec::__any_::__receiver_ref<stdexec::completion_signatures<stdexec::__rcvrs::set_stopped_t (), stdexec::__rcvrs::set_error_t (std::exception_ptr), stdexec::__rcvrs::set_value_t (boost::system::error_code)>, stdexec::__sync_wait::__env>]: call to deleted function call operator in type 'stdexec::__connect::_NO_USABLE_CONNECT_CUSTOMIZATION_FOUND_'
  257 |       auto operator()(_Sender&& __sndr, _Receiver&& __rcvr) const
      |            ^
In file included from main.cpp:1:
In file included from ./specific/ioexec/ioexec.hpp:3:
In file included from /opt/homebrew/include/stdexec/execution.hpp:38:
/opt/homebrew/include/stdexec/__detail/__let.hpp:491:25: error: no matching member function for call to 'apply'
  491 |           return __sndr.apply(
      |                  ~~~~~~~^~~~~
/opt/homebrew/include/stdexec/__detail/__meta.hpp:913:32: note: in instantiation of function template specialization 'stdexec::__let::__let_impl<stdexec::__rcvrs::set_value_t, stdexec::default_domain>::(anonymous class)::operator()<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, stdexec::__any_::__receiver_ref<stdexec::completion_signatures<stdexec::__rcvrs::set_stopped_t (), stdexec::__rcvrs::set_error_t (std::exception_ptr), stdexec::__rcvrs::set_value_t (boost::system::error_code)>, stdexec::__sync_wait::__env>>' requested here
  913 |   using __result_of = decltype(_Fun(__declval<_As>()...));
      |                                ^
/opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:76:5: note: in instantiation of template type alias '__result_of' requested here
   76 |     using __state_type_t =
      |     ^
/opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:80:5: note: in instantiation of template type alias '__state_type_t' requested here
   80 |     using __env_type_t = __result_of<
      |     ^
/opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:178:39: note: in instantiation of template type alias '__env_type_t' requested here
  178 |           get_env() const noexcept -> __env_type_t<_Self, __tag_t, _Idx, _Sexpr, _Receiver> {
      |                                       ^
/opt/homebrew/include/stdexec/__detail/__env.hpp:633:36: note: while substituting deduced template arguments into function template 'get_env' [with _Self = (no value)]
  633 |         -> decltype(__env_provider.get_env()) {
      |                                    ^
/opt/homebrew/include/stdexec/__detail/__tag_invoke.hpp:84:42: note: (skipping 86 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
   84 |     using tag_invoke_result_t = decltype(tag_invoke(__declval<_Tag>(), __declval<_Args>()...));
      |                                          ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:139:19: note: in instantiation of template type alias '__sync_wait_result_t' requested here
  139 |       using __t = __sync_wait_result_t<_Sender>;
      |                   ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:34:3: note: in instantiation of template class 'stdexec::__sync_wait::__value_tuple_for<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &>' requested here
   34 |   using __t = typename _Tp::__t;
      |   ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:142:5: note: in instantiation of template type alias '__t' requested here
  142 |     using __value_tuple_for_t = __t<__value_tuple_for<_Sender>>;
      |     ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:217:64: note: in instantiation of template type alias '__value_tuple_for_t' requested here
  217 |       auto operator()(_Sender&& __sndr) const -> std::optional<__value_tuple_for_t<_Sender>> {
      |                                                                ^
main.cpp:9:23: note: while substituting deduced template arguments into function template 'operator()' [with _Sender = __call_result_t<__binder_back<__let_t<set_value_t, dependent_domain>, (lambda at main.cpp:7:36)>, __sexpr<(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}, __anon>> &]
    9 |     stdexec::sync_wait(task);
      |                       ^
/opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:513:52: note: candidate template ignored: substitution failure [with _Sender = stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, _ApplyFn = (lambda at /opt/homebrew/include/stdexec/__detail/__let.hpp:493:13)]: no matching function for call to object of type '(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:404:14)'
  513 |     STDEXEC_ATTRIBUTE((always_inline)) static auto apply(_Sender&& __sndr, _ApplyFn&& __fun) //
      |                                                    ^
In file included from main.cpp:1:
In file included from ./specific/ioexec/ioexec.hpp:3:
In file included from /opt/homebrew/include/stdexec/execution.hpp:18:
In file included from /opt/homebrew/include/stdexec/__detail/__execution_fwd.hpp:19:
/opt/homebrew/include/stdexec/__detail/__meta.hpp:904:36: error: no matching function for call to object of type 'stdexec::__queries::get_scheduler_t'
  904 |   using __call_result_t = decltype(__declval<_Fun>()(__declval<_As>()...));
      |                                    ^~~~~~~~~~~~~~~~~
/opt/homebrew/include/stdexec/__detail/__read_env.hpp:99:28: note: in instantiation of template type alias '__call_result_t' requested here
   99 |           using __result = __call_result_t<__query, env_of_t<_Receiver>>;
      |                            ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:913:32: note: in instantiation of function template specialization 'stdexec::__read::__read_env_impl::(anonymous class)::operator()<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, stdexec::__detail::__receiver<stdexec::__detail::__receiver<stdexec::__any_::__receiver_ref<stdexec::completion_signatures<stdexec::__rcvrs::set_stopped_t (), stdexec::__rcvrs::set_error_t (std::exception_ptr), stdexec::__rcvrs::set_value_t (boost::system::error_code)>, stdexec::__sync_wait::__env>, stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, stdexec::__muchar (*)[1]>, stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, stdexec::__muchar (*)[1]>::__t>' requested here
  913 |   using __result_of = decltype(_Fun(__declval<_As>()...));
      |                                ^
/opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:76:5: note: in instantiation of template type alias '__result_of' requested here
   76 |     using __state_type_t =
      |     ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:411:5: note: in instantiation of template type alias '__state_type_t' requested here
  411 |     using __g = _Fn<_Args...>;
      |     ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:385:3: note: in instantiation of template type alias '__g' requested here
  385 |   using __meval =                  //
      |   ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:489:42: note: (skipping 128 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
  489 |   concept __mvalid = requires { typename __meval<_Tp, _Args...>; };
      |                                          ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:139:19: note: in instantiation of template type alias '__sync_wait_result_t' requested here
  139 |       using __t = __sync_wait_result_t<_Sender>;
      |                   ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:34:3: note: in instantiation of template class 'stdexec::__sync_wait::__value_tuple_for<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &>' requested here
   34 |   using __t = typename _Tp::__t;
      |   ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:142:5: note: in instantiation of template type alias '__t' requested here
  142 |     using __value_tuple_for_t = __t<__value_tuple_for<_Sender>>;
      |     ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:217:64: note: in instantiation of template type alias '__value_tuple_for_t' requested here
  217 |       auto operator()(_Sender&& __sndr) const -> std::optional<__value_tuple_for_t<_Sender>> {
      |                                                                ^
main.cpp:9:23: note: while substituting deduced template arguments into function template 'operator()' [with _Sender = __call_result_t<__binder_back<__let_t<set_value_t, dependent_domain>, (lambda at main.cpp:7:36)>, __sexpr<(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}, __anon>> &]
    9 |     stdexec::sync_wait(task);
      |                       ^
/opt/homebrew/include/stdexec/__detail/__schedulers.hpp:92:34: note: candidate template ignored: substitution failure [with _Env = stdexec::__env::env<>]: no matching function for call to 'tag_invoke'
   92 |     inline auto get_scheduler_t::operator()(const _Env& __env) const noexcept
      |                                  ^
/opt/homebrew/include/stdexec/__detail/__read_env.hpp:134:34: note: candidate function template not viable: requires 0 arguments, but 1 was provided
  134 |     inline auto get_scheduler_t::operator()() const noexcept {
      |                                  ^
In file included from main.cpp:1:
./specific/ioexec/ioexec.hpp:22:22: error: deduced type 'void' does not satisfy 'operation_state'
   22 |             stdexec::operation_state auto connect ( stdexec::receiver auto&& );
      |             ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
/opt/homebrew/include/stdexec/__detail/__senders.hpp:161:61: note: in instantiation of function template specialization 'ioexec::sender<boost::system::error_code>::connect<stdexec::__detail::__receiver<stdexec::__sync_wait::__receiver<boost::system::error_code>, stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, stdexec::__muchar (*)[1]>::__t>' requested here
  161 |     using __member_result_t = decltype(__declval<_Sender>().connect(__declval<_Receiver>()));
      |                                                             ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:411:5: note: in instantiation of template type alias '__member_result_t' requested here
  411 |     using __g = _Fn<_Args...>;
      |     ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:385:3: note: in instantiation of template type alias '__g' requested here
  385 |   using __meval =                  //
      |   ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:489:42: note: in instantiation of template type alias '__meval' requested here
  489 |   concept __mvalid = requires { typename __meval<_Tp, _Args...>; };
      |                                          ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:489:33: note: in instantiation of requirement here
  489 |   concept __mvalid = requires { typename __meval<_Tp, _Args...>; };
      |                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/opt/homebrew/include/stdexec/__detail/__meta.hpp:489:22: note: (skipping 143 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
  489 |   concept __mvalid = requires { typename __meval<_Tp, _Args...>; };
      |                      ^
/opt/homebrew/include/stdexec/__detail/__senders.hpp:213:23: note: while checking the satisfaction of concept '__with_static_member<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, stdexec::__sync_wait::__receiver<boost::system::error_code>::__t>' requested here
  213 |         if constexpr (__with_static_member<_TfxSender, _Receiver>) {
      |                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/opt/homebrew/include/stdexec/__detail/__senders.hpp:254:40: note: in instantiation of function template specialization 'stdexec::__connect::connect_t::__select_impl<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &, stdexec::__sync_wait::__receiver<boost::system::error_code>::__t>' requested here
  254 |       using __select_impl_t = decltype(__select_impl<_Sender, _Receiver>());
      |                                        ^
/opt/homebrew/include/stdexec/__detail/__senders.hpp:259:30: note: in instantiation of template type alias '__select_impl_t' requested here
  259 |           -> __call_result_t<__select_impl_t<_Sender, _Receiver>> {
      |                              ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:272:11: note: while substituting deduced template arguments into function template 'operator()' [with _Sender = stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &, _Receiver = __receiver_t<__sexpr<(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}, __anon> &>]
  272 |           connect(static_cast<_Sender&&>(__sndr), __receiver_t<_Sender>{&__local_state, &__result});
      |           ^
/opt/homebrew/include/stdexec/__detail/__domain.hpp:179:23: note: in instantiation of function template specialization 'stdexec::__sync_wait::sync_wait_t::apply_sender<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &>' requested here
  179 |         return _Tag().apply_sender(static_cast<_Sender&&>(__sndr), static_cast<_Args&&>(__args)...);
      |                       ^
/opt/homebrew/include/stdexec/__detail/__operation_states.hpp:57:5: note: because 'void' does not satisfy 'destructible'
   57 |     destructible<_Op> &&     //
      |     ^
/opt/homebrew/include/stdexec/__detail/__concepts.hpp:147:26: note: because '__is_nothrow_destructible(void)' evaluated to false
  147 |   concept destructible = __is_nothrow_destructible(_Ty);
      |                          ^
In file included from main.cpp:1:
In file included from ./specific/ioexec/ioexec.hpp:3:
In file included from /opt/homebrew/include/stdexec/execution.hpp:18:
In file included from /opt/homebrew/include/stdexec/__detail/__execution_fwd.hpp:19:
/opt/homebrew/include/stdexec/__detail/__meta.hpp:904:36: error: no matching function for call to object of type 'stdexec::__connect::connect_t'
  904 |   using __call_result_t = decltype(__declval<_Fun>()(__declval<_As>()...));
      |                                    ^~~~~~~~~~~~~~~~~
/opt/homebrew/include/stdexec/__detail/__senders_core.hpp:77:3: note: in instantiation of template type alias '__call_result_t' requested here
   77 |   using connect_result_t = __call_result_t<connect_t, _Sender, _Receiver>;
      |   ^
/opt/homebrew/include/stdexec/__detail/__let.hpp:222:5: note: in instantiation of template type alias 'connect_result_t' requested here
  222 |     using __op_state_t = connect_result_t<
      |     ^
/opt/homebrew/include/stdexec/__detail/__let.hpp:354:7: note: in instantiation of template type alias '__op_state_t' requested here
  354 |       using __f = __op_state_t<
      |       ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:393:3: note: in instantiation of template type alias '__f' requested here
  393 |   using __minvoke =                       //
      |   ^
/opt/homebrew/include/stdexec/__detail/__tuple.hpp:252:5: note: in instantiation of template type alias '__minvoke' requested here
  252 |     using __f = __minvoke<_Fn, _Ts...>;
      |     ^
/opt/homebrew/include/stdexec/__detail/__meta.hpp:710:5: note: (skipping 103 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
  710 |     using __f = typename __muncurry_<_Tp>::template __f<_Fn>;
      |     ^
/opt/homebrew/include/stdexec/__detail/__senders.hpp:213:23: note: while checking the satisfaction of concept '__with_static_member<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, stdexec::__sync_wait::__receiver<boost::system::error_code>::__t>' requested here
  213 |         if constexpr (__with_static_member<_TfxSender, _Receiver>) {
      |                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/opt/homebrew/include/stdexec/__detail/__senders.hpp:254:40: note: in instantiation of function template specialization 'stdexec::__connect::connect_t::__select_impl<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &, stdexec::__sync_wait::__receiver<boost::system::error_code>::__t>' requested here
  254 |       using __select_impl_t = decltype(__select_impl<_Sender, _Receiver>());
      |                                        ^
/opt/homebrew/include/stdexec/__detail/__senders.hpp:259:30: note: in instantiation of template type alias '__select_impl_t' requested here
  259 |           -> __call_result_t<__select_impl_t<_Sender, _Receiver>> {
      |                              ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:272:11: note: while substituting deduced template arguments into function template 'operator()' [with _Sender = stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &, _Receiver = __receiver_t<__sexpr<(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}, __anon> &>]
  272 |           connect(static_cast<_Sender&&>(__sndr), __receiver_t<_Sender>{&__local_state, &__result});
      |           ^
/opt/homebrew/include/stdexec/__detail/__domain.hpp:179:23: note: in instantiation of function template specialization 'stdexec::__sync_wait::sync_wait_t::apply_sender<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &>' requested here
  179 |         return _Tag().apply_sender(static_cast<_Sender&&>(__sndr), static_cast<_Args&&>(__args)...);
      |                       ^
/opt/homebrew/include/stdexec/__detail/__senders.hpp:257:12: note: candidate template ignored: substitution failure [with _Sender = stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, _Receiver = stdexec::__sync_wait::__receiver<boost::system::error_code>::__t]: call to deleted function call operator in type 'stdexec::__connect::_NO_USABLE_CONNECT_CUSTOMIZATION_FOUND_'
  257 |       auto operator()(_Sender&& __sndr, _Receiver&& __rcvr) const
      |            ^
In file included from main.cpp:1:
In file included from ./specific/ioexec/ioexec.hpp:3:
In file included from /opt/homebrew/include/stdexec/execution.hpp:38:
/opt/homebrew/include/stdexec/__detail/__let.hpp:491:25: error: no matching member function for call to 'apply'
  491 |           return __sndr.apply(
      |                  ~~~~~~~^~~~~
/opt/homebrew/include/stdexec/__detail/__meta.hpp:913:32: note: in instantiation of function template specialization 'stdexec::__let::__let_impl<stdexec::__rcvrs::set_value_t, stdexec::default_domain>::(anonymous class)::operator()<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, stdexec::__sync_wait::__receiver<boost::system::error_code>::__t>' requested here
  913 |   using __result_of = decltype(_Fun(__declval<_As>()...));
      |                                ^
/opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:76:5: note: in instantiation of template type alias '__result_of' requested here
   76 |     using __state_type_t =
      |     ^
/opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:80:5: note: in instantiation of template type alias '__state_type_t' requested here
   80 |     using __env_type_t = __result_of<
      |     ^
/opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:178:39: note: in instantiation of template type alias '__env_type_t' requested here
  178 |           get_env() const noexcept -> __env_type_t<_Self, __tag_t, _Idx, _Sexpr, _Receiver> {
      |                                       ^
/opt/homebrew/include/stdexec/__detail/__env.hpp:633:36: note: while substituting deduced template arguments into function template 'get_env' [with _Self = (no value)]
  633 |         -> decltype(__env_provider.get_env()) {
      |                                    ^
/opt/homebrew/include/stdexec/__detail/__tag_invoke.hpp:84:42: note: (skipping 88 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
   84 |     using tag_invoke_result_t = decltype(tag_invoke(__declval<_Tag>(), __declval<_Args>()...));
      |                                          ^
/opt/homebrew/include/stdexec/__detail/__senders.hpp:213:23: note: while checking the satisfaction of concept '__with_static_member<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, stdexec::__sync_wait::__receiver<boost::system::error_code>::__t>' requested here
  213 |         if constexpr (__with_static_member<_TfxSender, _Receiver>) {
      |                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/opt/homebrew/include/stdexec/__detail/__senders.hpp:254:40: note: in instantiation of function template specialization 'stdexec::__connect::connect_t::__select_impl<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &, stdexec::__sync_wait::__receiver<boost::system::error_code>::__t>' requested here
  254 |       using __select_impl_t = decltype(__select_impl<_Sender, _Receiver>());
      |                                        ^
/opt/homebrew/include/stdexec/__detail/__senders.hpp:259:30: note: in instantiation of template type alias '__select_impl_t' requested here
  259 |           -> __call_result_t<__select_impl_t<_Sender, _Receiver>> {
      |                              ^
/opt/homebrew/include/stdexec/__detail/__sync_wait.hpp:272:11: note: while substituting deduced template arguments into function template 'operator()' [with _Sender = stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &, _Receiver = __receiver_t<__sexpr<(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}, __anon> &>]
  272 |           connect(static_cast<_Sender&&>(__sndr), __receiver_t<_Sender>{&__local_state, &__result});
      |           ^
/opt/homebrew/include/stdexec/__detail/__domain.hpp:179:23: note: in instantiation of function template specialization 'stdexec::__sync_wait::sync_wait_t::apply_sender<stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}> &>' requested here
  179 |         return _Tag().apply_sender(static_cast<_Sender&&>(__sndr), static_cast<_Args&&>(__args)...);
      |                       ^
/opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:513:52: note: candidate template ignored: substitution failure [with _Sender = stdexec::__sexpr<stdexec::(anonymous namespace)::(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:46:9){}>, _ApplyFn = (lambda at /opt/homebrew/include/stdexec/__detail/__let.hpp:493:13)]: no matching function for call to object of type '(lambda at /opt/homebrew/include/stdexec/__detail/__basic_sender.hpp:404:14)'
  513 |     STDEXEC_ATTRIBUTE((always_inline)) static auto apply(_Sender&& __sndr, _ApplyFn&& __fun) //
      |                                                    ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
