// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

// WARNING, this entire header is generated by
// utils/generate_libcxx_cppm_in.py
// DO NOT MODIFY!

module;
#undef in

#include <__config>

// The headers of Table 24: C++ library headers [tab:headers.cpp]
// and the headers of Table 25: C++ headers for C library facilities [tab:headers.cpp.c]
#include <algorithm>
#include <any>
#include <array>
#if _LIBCPP_HAS_ATOMIC_HEADER
#  include <atomic>
#endif
#include <barrier>
#include <bit>
#include <bitset>
#include <cassert>
#include <cctype>
#include <cerrno>
#include <cfenv>
#include <cfloat>
#include <charconv>
#include <chrono>
#include <cinttypes>
#include <climits>
#if _LIBCPP_HAS_LOCALIZATION
#  include <clocale>
#endif
#include <cmath>
#if _LIBCPP_HAS_LOCALIZATION
#  include <codecvt>
#endif
#include <compare>
#include <complex>
#include <concepts>
#include <condition_variable>
#include <coroutine>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <cuchar>
#include <cwchar>
#include <cwctype>
#include <deque>
#include <exception>
#include <execution>
#include <expected>
#include <filesystem>
#include <flat_map>
#include <format>
#include <forward_list>
#if _LIBCPP_HAS_LOCALIZATION
#  include <fstream>
#endif
#include <functional>
#include <future>
#include <initializer_list>
#if _LIBCPP_HAS_LOCALIZATION
#  include <iomanip>
#endif
#if _LIBCPP_HAS_LOCALIZATION
#  include <ios>
#endif
#include <iosfwd>
#if _LIBCPP_HAS_LOCALIZATION
#  include <iostream>
#endif
#if _LIBCPP_HAS_LOCALIZATION
#  include <istream>
#endif
#include <iterator>
#include <latch>
#include <limits>
#include <list>
#if _LIBCPP_HAS_LOCALIZATION
#  include <locale>
#endif
#include <map>
#include <mdspan>
#include <memory>
#include <memory_resource>
#include <mutex>
#include <new>
#include <numbers>
#include <numeric>
#include <optional>
#if _LIBCPP_HAS_LOCALIZATION
#  include <ostream>
#endif
#include <print>
#include <queue>
#include <random>
#include <ranges>
#include <ratio>
#if _LIBCPP_HAS_LOCALIZATION
#  include <regex>
#endif
#include <scoped_allocator>
#include <semaphore>
#include <set>
#include <shared_mutex>
#include <source_location>
#include <span>
#if _LIBCPP_HAS_LOCALIZATION
#  include <sstream>
#endif
#include <stack>
#include <stdexcept>
#include <stop_token>
#if _LIBCPP_HAS_LOCALIZATION
#  include <streambuf>
#endif
#include <string>
#include <string_view>
#if _LIBCPP_HAS_LOCALIZATION
#  include <strstream>
#endif
#if _LIBCPP_HAS_LOCALIZATION
#  include <syncstream>
#endif
#include <system_error>
#include <thread>
#include <tuple>
#include <type_traits>
#include <typeindex>
#include <typeinfo>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <valarray>
#include <variant>
#include <vector>
#include <version>

// *** Headers not yet available ***
//
// This validation is mainly to catch when a new header is added but adding the
// corresponding .inc file is forgotten. However, the check based on __has_include
// alone doesn't work on Windows because the Windows SDK is on the include path,
// and that means the MSVC STL headers can be found as well, tricking __has_include
// into thinking that libc++ provides the header.
//
#ifndef _WIN32
#  if __has_include(<debugging>)
#    error "please update the header information for <debugging> in headers_not_available in utils/libcxx/header_information.py"
#  endif // __has_include(<debugging>)
#  if __has_include(<flat_set>)
#    error "please update the header information for <flat_set> in headers_not_available in utils/libcxx/header_information.py"
#  endif // __has_include(<flat_set>)
#  if __has_include(<generator>)
#    error "please update the header information for <generator> in headers_not_available in utils/libcxx/header_information.py"
#  endif // __has_include(<generator>)
#  if __has_include(<hazard_pointer>)
#    error "please update the header information for <hazard_pointer> in headers_not_available in utils/libcxx/header_information.py"
#  endif // __has_include(<hazard_pointer>)
#  if __has_include(<inplace_vector>)
#    error "please update the header information for <inplace_vector> in headers_not_available in utils/libcxx/header_information.py"
#  endif // __has_include(<inplace_vector>)
#  if __has_include(<linalg>)
#    error "please update the header information for <linalg> in headers_not_available in utils/libcxx/header_information.py"
#  endif // __has_include(<linalg>)
#  if __has_include(<rcu>)
#    error "please update the header information for <rcu> in headers_not_available in utils/libcxx/header_information.py"
#  endif // __has_include(<rcu>)
#  if __has_include(<spanstream>)
#    error "please update the header information for <spanstream> in headers_not_available in utils/libcxx/header_information.py"
#  endif // __has_include(<spanstream>)
#  if __has_include(<stacktrace>)
#    error "please update the header information for <stacktrace> in headers_not_available in utils/libcxx/header_information.py"
#  endif // __has_include(<stacktrace>)
#  if __has_include(<stdfloat>)
#    error "please update the header information for <stdfloat> in headers_not_available in utils/libcxx/header_information.py"
#  endif // __has_include(<stdfloat>)
#  if __has_include(<text_encoding>)
#    error "please update the header information for <text_encoding> in headers_not_available in utils/libcxx/header_information.py"
#  endif // __has_include(<text_encoding>)
#endif // _WIN32

export module std.compiler.clang;

export namespace std {
  namespace ranges {
    using std::ranges::in_found_result;
    using std::ranges::in_fun_result;
    using std::ranges::in_in_out_result;
    using std::ranges::in_in_result;
    using std::ranges::in_out_out_result;
    using std::ranges::in_out_result;
    using std::ranges::in_value_result;
    using std::ranges::min_max_result;
  }
  using std::all_of;
  namespace ranges {
    using std::ranges::all_of;
  }
  using std::any_of;
  namespace ranges {
    using std::ranges::any_of;
  }
  using std::none_of;
  namespace ranges {
    using std::ranges::none_of;
  }
  namespace ranges {
    using std::ranges::contains;
    using std::ranges::contains_subrange;
  }
  using std::for_each;
  namespace ranges {
    using std::ranges::for_each;
    using std::ranges::for_each_result;
  }
  using std::for_each_n;
  namespace ranges {
    using std::ranges::for_each_n_result;
    using std::ranges::for_each_n;
  }
  using std::find;
  using std::find_if;
  using std::find_if_not;
  namespace ranges {
    using std::ranges::find;
    using std::ranges::find_if;
    using std::ranges::find_if_not;
  }
  namespace ranges {
    using std::ranges::find_last;
    using std::ranges::find_last_if;
    using std::ranges::find_last_if_not;
  }
  using std::find_end;
  namespace ranges {
    using std::ranges::find_end;
  }
  using std::find_first_of;
  namespace ranges {
    using std::ranges::find_first_of;
  }
  using std::adjacent_find;
  namespace ranges {
    using std::ranges::adjacent_find;
  }
  using std::count;
  using std::count_if;
  namespace ranges {
    using std::ranges::count;
    using std::ranges::count_if;
  }
  using std::mismatch;
  namespace ranges {
    using std::ranges::mismatch_result;
    using std::ranges::mismatch;
  }
  using std::equal;
  namespace ranges {
    using std::ranges::equal;
  }
  using std::is_permutation;
  namespace ranges {
    using std::ranges::is_permutation;
  }
  using std::search;
  namespace ranges {
    using std::ranges::search;
  }
  using std::search_n;
  namespace ranges {
    using std::ranges::search_n;
  }
  namespace ranges {
    using std::ranges::starts_with;
    using std::ranges::ends_with;
    using std::ranges::fold_left;
    using std::ranges::fold_left_with_iter;
    using std::ranges::fold_left_with_iter_result;
  }
  using std::copy;
  namespace ranges {
    using std::ranges::copy;
    using std::ranges::copy_result;
  }
  using std::copy_n;
  namespace ranges {
    using std::ranges::copy_n;
    using std::ranges::copy_n_result;
  }
  using std::copy_if;
  namespace ranges {
    using std::ranges::copy_if;
    using std::ranges::copy_if_result;
  }
  using std::copy_backward;
  namespace ranges {
    using std::ranges::copy_backward;
    using std::ranges::copy_backward_result;
  }
  using std::move;
  namespace ranges {
    using std::ranges::move;
    using std::ranges::move_result;
  }
  using std::move_backward;
  namespace ranges {
    using std::ranges::move_backward;
    using std::ranges::move_backward_result;
  }
  using std::swap_ranges;
  namespace ranges {
    using std::ranges::swap_ranges;
    using std::ranges::swap_ranges_result;
  }
  using std::iter_swap;
  using std::transform;
  namespace ranges {
    using std::ranges::binary_transform_result;
    using std::ranges::unary_transform_result;
    using std::ranges::transform;
  }
  using std::replace;
  using std::replace_if;
  namespace ranges {
    using std::ranges::replace;
    using std::ranges::replace_if;
  }
  using std::replace_copy;
  using std::replace_copy_if;
  namespace ranges {
    using std::ranges::replace_copy;
    using std::ranges::replace_copy_if;
    using std::ranges::replace_copy_if_result;
    using std::ranges::replace_copy_result;
  }
  using std::fill;
  using std::fill_n;
  namespace ranges {
    using std::ranges::fill;
    using std::ranges::fill_n;
  }
  using std::generate;
  using std::generate_n;
  namespace ranges {
    using std::ranges::generate;
    using std::ranges::generate_n;
  }
  using std::remove;
  using std::remove_if;
  namespace ranges {
    using std::ranges::remove;
    using std::ranges::remove_if;
  }
  using std::remove_copy;
  using std::remove_copy_if;
  namespace ranges {
    using std::ranges::remove_copy;
    using std::ranges::remove_copy_if;
    using std::ranges::remove_copy_if_result;
    using std::ranges::remove_copy_result;
  }
  using std::unique;
  namespace ranges {
    using std::ranges::unique;
  }
  using std::unique_copy;
  namespace ranges {
    using std::ranges::unique_copy;
    using std::ranges::unique_copy_result;
  }
  using std::reverse;
  namespace ranges {
    using std::ranges::reverse;
  }
  using std::reverse_copy;
  namespace ranges {
    using std::ranges::reverse_copy;
    using std::ranges::reverse_copy_result;
  }
  using std::rotate;
  namespace ranges {
    using std::ranges::rotate;
  }
  using std::rotate_copy;
  namespace ranges {
    using std::ranges::rotate_copy;
    using std::ranges::rotate_copy_result;
  }
  using std::sample;
  namespace ranges {
    using std::ranges::sample;
  }
  using std::shuffle;
  namespace ranges {
    using std::ranges::shuffle;
  }
  using std::shift_left;
  namespace ranges {
  }
  using std::shift_right;
  namespace ranges {
  }
  using std::sort;
  namespace ranges {
    using std::ranges::sort;
  }
  using std::stable_sort;
  namespace ranges {
    using std::ranges::stable_sort;
  }
  using std::partial_sort;
  namespace ranges {
    using std::ranges::partial_sort;
  }
  using std::partial_sort_copy;
  namespace ranges {
    using std::ranges::partial_sort_copy;
    using std::ranges::partial_sort_copy_result;
  }
  using std::is_sorted;
  using std::is_sorted_until;
  namespace ranges {
    using std::ranges::is_sorted;
    using std::ranges::is_sorted_until;
  }
  using std::nth_element;
  namespace ranges {
    using std::ranges::nth_element;
  }
  using std::lower_bound;
  namespace ranges {
    using std::ranges::lower_bound;
  }
  using std::upper_bound;
  namespace ranges {
    using std::ranges::upper_bound;
  }
  using std::equal_range;
  namespace ranges {
    using std::ranges::equal_range;
  }
  using std::binary_search;
  namespace ranges {
    using std::ranges::binary_search;
  }
  using std::is_partitioned;
  namespace ranges {
    using std::ranges::is_partitioned;
  }
  using std::partition;
  namespace ranges {
    using std::ranges::partition;
  }
  using std::stable_partition;
  namespace ranges {
    using std::ranges::stable_partition;
  }
  using std::partition_copy;
  namespace ranges {
    using std::ranges::partition_copy;
    using std::ranges::partition_copy_result;
  }
  using std::partition_point;
  namespace ranges {
    using std::ranges::partition_point;
  }
  using std::merge;
  namespace ranges {
    using std::ranges::merge;
    using std::ranges::merge_result;
  }
  using std::inplace_merge;
  namespace ranges {
    using std::ranges::inplace_merge;
  }
  using std::includes;
  namespace ranges {
    using std::ranges::includes;
  }
  using std::set_union;
  namespace ranges {
    using std::ranges::set_union;
    using std::ranges::set_union_result;
  }
  using std::set_intersection;
  namespace ranges {
    using std::ranges::set_intersection;
    using std::ranges::set_intersection_result;
  }
  using std::set_difference;
  namespace ranges {
    using std::ranges::set_difference;
    using std::ranges::set_difference_result;
  }
  using std::set_symmetric_difference;
  namespace ranges {
    using std::ranges::set_symmetric_difference_result;
    using std::ranges::set_symmetric_difference;
  }
  using std::push_heap;
  namespace ranges {
    using std::ranges::push_heap;
  }
  using std::pop_heap;
  namespace ranges {
    using std::ranges::pop_heap;
  }
  using std::make_heap;
  namespace ranges {
    using std::ranges::make_heap;
  }
  using std::sort_heap;
  namespace ranges {
    using std::ranges::sort_heap;
  }
  using std::is_heap;
  namespace ranges {
    using std::ranges::is_heap;
  }
  using std::is_heap_until;
  namespace ranges {
    using std::ranges::is_heap_until;
  }
  using std::min;
  namespace ranges {
    using std::ranges::min;
  }
  using std::max;
  namespace ranges {
    using std::ranges::max;
  }
  using std::minmax;
  namespace ranges {
    using std::ranges::minmax_result;
    using std::ranges::minmax;
  }
  using std::min_element;
  namespace ranges {
    using std::ranges::min_element;
  }
  using std::max_element;
  namespace ranges {
    using std::ranges::max_element;
  }
  using std::minmax_element;
  namespace ranges {
    using std::ranges::minmax_element_result;
    using std::ranges::minmax_element;
  }
  using std::clamp;
  namespace ranges {
    using std::ranges::clamp;
  }
  using std::lexicographical_compare;
  namespace ranges {
    using std::ranges::lexicographical_compare;
  }
  using std::lexicographical_compare_three_way;
  using std::next_permutation;
  namespace ranges {
    using std::ranges::next_permutation_result;
    using std::ranges::next_permutation;
  }
  using std::prev_permutation;
  namespace ranges {
    using std::ranges::prev_permutation_result;
    using std::ranges::prev_permutation;
  }
}
export namespace std {
  using std::bad_any_cast;
  using std::any;
  using std::any_cast;
  using std::make_any;
  using std::swap;
}
export namespace std {
  using std::array;
  using std::operator==;
  using std::operator<=>;
  using std::swap;
  using std::to_array;
  using std::get;
  using std::tuple_element;
  using std::tuple_size;
}
export namespace std {
  using std::memory_order __attribute__((__using_if_exists__));
  using std::memory_order_acq_rel __attribute__((__using_if_exists__));
  using std::memory_order_acquire __attribute__((__using_if_exists__));
  using std::memory_order_consume __attribute__((__using_if_exists__));
  using std::memory_order_relaxed __attribute__((__using_if_exists__));
  using std::memory_order_release __attribute__((__using_if_exists__));
  using std::memory_order_seq_cst __attribute__((__using_if_exists__));
  using std::kill_dependency __attribute__((__using_if_exists__));
  using std::atomic_ref __attribute__((__using_if_exists__));
  using std::atomic __attribute__((__using_if_exists__));
  using std::atomic_compare_exchange_strong __attribute__((__using_if_exists__));
  using std::atomic_compare_exchange_strong_explicit __attribute__((__using_if_exists__));
  using std::atomic_compare_exchange_weak __attribute__((__using_if_exists__));
  using std::atomic_compare_exchange_weak_explicit __attribute__((__using_if_exists__));
  using std::atomic_exchange __attribute__((__using_if_exists__));
  using std::atomic_exchange_explicit __attribute__((__using_if_exists__));
  using std::atomic_is_lock_free __attribute__((__using_if_exists__));
  using std::atomic_load __attribute__((__using_if_exists__));
  using std::atomic_load_explicit __attribute__((__using_if_exists__));
  using std::atomic_store __attribute__((__using_if_exists__));
  using std::atomic_store_explicit __attribute__((__using_if_exists__));
  using std::atomic_fetch_add __attribute__((__using_if_exists__));
  using std::atomic_fetch_add_explicit __attribute__((__using_if_exists__));
  using std::atomic_fetch_and __attribute__((__using_if_exists__));
  using std::atomic_fetch_and_explicit __attribute__((__using_if_exists__));
  using std::atomic_fetch_or __attribute__((__using_if_exists__));
  using std::atomic_fetch_or_explicit __attribute__((__using_if_exists__));
  using std::atomic_fetch_sub __attribute__((__using_if_exists__));
  using std::atomic_fetch_sub_explicit __attribute__((__using_if_exists__));
  using std::atomic_fetch_xor __attribute__((__using_if_exists__));
  using std::atomic_fetch_xor_explicit __attribute__((__using_if_exists__));
  using std::atomic_notify_all __attribute__((__using_if_exists__));
  using std::atomic_notify_one __attribute__((__using_if_exists__));
  using std::atomic_wait __attribute__((__using_if_exists__));
  using std::atomic_wait_explicit __attribute__((__using_if_exists__));
  using std::atomic_bool __attribute__((__using_if_exists__));
  using std::atomic_char __attribute__((__using_if_exists__));
  using std::atomic_char16_t __attribute__((__using_if_exists__));
  using std::atomic_char32_t __attribute__((__using_if_exists__));
  using std::atomic_char8_t __attribute__((__using_if_exists__));
  using std::atomic_int __attribute__((__using_if_exists__));
  using std::atomic_llong __attribute__((__using_if_exists__));
  using std::atomic_long __attribute__((__using_if_exists__));
  using std::atomic_schar __attribute__((__using_if_exists__));
  using std::atomic_short __attribute__((__using_if_exists__));
  using std::atomic_uchar __attribute__((__using_if_exists__));
  using std::atomic_uint __attribute__((__using_if_exists__));
  using std::atomic_ullong __attribute__((__using_if_exists__));
  using std::atomic_ulong __attribute__((__using_if_exists__));
  using std::atomic_ushort __attribute__((__using_if_exists__));
  using std::atomic_wchar_t __attribute__((__using_if_exists__));
  using std::atomic_int16_t __attribute__((__using_if_exists__));
  using std::atomic_int32_t __attribute__((__using_if_exists__));
  using std::atomic_int64_t __attribute__((__using_if_exists__));
  using std::atomic_int8_t __attribute__((__using_if_exists__));
  using std::atomic_uint16_t __attribute__((__using_if_exists__));
  using std::atomic_uint32_t __attribute__((__using_if_exists__));
  using std::atomic_uint64_t __attribute__((__using_if_exists__));
  using std::atomic_uint8_t __attribute__((__using_if_exists__));
  using std::atomic_int_least16_t __attribute__((__using_if_exists__));
  using std::atomic_int_least32_t __attribute__((__using_if_exists__));
  using std::atomic_int_least64_t __attribute__((__using_if_exists__));
  using std::atomic_int_least8_t __attribute__((__using_if_exists__));
  using std::atomic_uint_least16_t __attribute__((__using_if_exists__));
  using std::atomic_uint_least32_t __attribute__((__using_if_exists__));
  using std::atomic_uint_least64_t __attribute__((__using_if_exists__));
  using std::atomic_uint_least8_t __attribute__((__using_if_exists__));
  using std::atomic_int_fast16_t __attribute__((__using_if_exists__));
  using std::atomic_int_fast32_t __attribute__((__using_if_exists__));
  using std::atomic_int_fast64_t __attribute__((__using_if_exists__));
  using std::atomic_int_fast8_t __attribute__((__using_if_exists__));
  using std::atomic_uint_fast16_t __attribute__((__using_if_exists__));
  using std::atomic_uint_fast32_t __attribute__((__using_if_exists__));
  using std::atomic_uint_fast64_t __attribute__((__using_if_exists__));
  using std::atomic_uint_fast8_t __attribute__((__using_if_exists__));
  using std::atomic_intmax_t __attribute__((__using_if_exists__));
  using std::atomic_intptr_t __attribute__((__using_if_exists__));
  using std::atomic_ptrdiff_t __attribute__((__using_if_exists__));
  using std::atomic_size_t __attribute__((__using_if_exists__));
  using std::atomic_uintmax_t __attribute__((__using_if_exists__));
  using std::atomic_uintptr_t __attribute__((__using_if_exists__));
  using std::atomic_signed_lock_free __attribute__((__using_if_exists__));
  using std::atomic_unsigned_lock_free __attribute__((__using_if_exists__));
  using std::atomic_flag __attribute__((__using_if_exists__));
  using std::atomic_flag_clear __attribute__((__using_if_exists__));
  using std::atomic_flag_clear_explicit __attribute__((__using_if_exists__));
  using std::atomic_flag_test __attribute__((__using_if_exists__));
  using std::atomic_flag_test_and_set __attribute__((__using_if_exists__));
  using std::atomic_flag_test_and_set_explicit __attribute__((__using_if_exists__));
  using std::atomic_flag_test_explicit __attribute__((__using_if_exists__));
  using std::atomic_flag_notify_all __attribute__((__using_if_exists__));
  using std::atomic_flag_notify_one __attribute__((__using_if_exists__));
  using std::atomic_flag_wait __attribute__((__using_if_exists__));
  using std::atomic_flag_wait_explicit __attribute__((__using_if_exists__));
  using std::atomic_signal_fence __attribute__((__using_if_exists__));
  using std::atomic_thread_fence __attribute__((__using_if_exists__));
  using std::atomic_init __attribute__((__using_if_exists__));
}
export namespace std {
  using std::barrier;
}
export namespace std {
  using std::bit_cast;
  using std::byteswap;
  using std::bit_ceil;
  using std::bit_floor;
  using std::bit_width;
  using std::has_single_bit;
  using std::rotl;
  using std::rotr;
  using std::countl_one;
  using std::countl_zero;
  using std::countr_one;
  using std::countr_zero;
  using std::popcount;
  using std::endian;
}
export namespace std {
  using std::bitset;
  using std::operator&;
  using std::operator|;
  using std::operator^;
  using std::operator>>;
  using std::operator<<;
  using std::hash;
}
export namespace std {
}
export namespace std {
  using std::isalnum __attribute__((__using_if_exists__));
  using std::isalpha __attribute__((__using_if_exists__));
  using std::isblank __attribute__((__using_if_exists__));
  using std::iscntrl __attribute__((__using_if_exists__));
  using std::isdigit __attribute__((__using_if_exists__));
  using std::isgraph __attribute__((__using_if_exists__));
  using std::islower __attribute__((__using_if_exists__));
  using std::isprint __attribute__((__using_if_exists__));
  using std::ispunct __attribute__((__using_if_exists__));
  using std::isspace __attribute__((__using_if_exists__));
  using std::isupper __attribute__((__using_if_exists__));
  using std::isxdigit __attribute__((__using_if_exists__));
  using std::tolower __attribute__((__using_if_exists__));
  using std::toupper __attribute__((__using_if_exists__));
}
export namespace std {
}
export namespace std {
  using std::fenv_t __attribute__((__using_if_exists__));
  using std::fexcept_t __attribute__((__using_if_exists__));
  using std::feclearexcept __attribute__((__using_if_exists__));
  using std::fegetexceptflag __attribute__((__using_if_exists__));
  using std::feraiseexcept __attribute__((__using_if_exists__));
  using std::fesetexceptflag __attribute__((__using_if_exists__));
  using std::fetestexcept __attribute__((__using_if_exists__));
  using std::fegetround __attribute__((__using_if_exists__));
  using std::fesetround __attribute__((__using_if_exists__));
  using std::fegetenv __attribute__((__using_if_exists__));
  using std::feholdexcept __attribute__((__using_if_exists__));
  using std::fesetenv __attribute__((__using_if_exists__));
  using std::feupdateenv __attribute__((__using_if_exists__));
}
export namespace std {
}
export namespace std {
  using std::chars_format;
  using std::operator&;
  using std::operator&=;
  using std::operator^;
  using std::operator^=;
  using std::operator|;
  using std::operator|=;
  using std::operator~;
  using std::to_chars_result;
  using std::to_chars;
  using std::from_chars_result;
  using std::from_chars;
}
export namespace std {
  namespace chrono {
    using std::chrono::duration;
    using std::chrono::time_point;
  }
  using std::common_type;
  namespace chrono {
    using std::chrono::treat_as_floating_point;
    using std::chrono::treat_as_floating_point_v;
    using std::chrono::duration_values;
    using std::chrono::operator+;
    using std::chrono::operator-;
    using std::chrono::operator*;
    using std::chrono::operator/;
    using std::chrono::operator%;
    using std::chrono::operator==;
    using std::chrono::operator<;
    using std::chrono::operator>;
    using std::chrono::operator<=;
    using std::chrono::operator>=;
    using std::chrono::operator<=>;
    using std::chrono::ceil;
    using std::chrono::duration_cast;
    using std::chrono::floor;
    using std::chrono::round;
    using std::chrono::operator<<;
    using std::chrono::days;
    using std::chrono::hours;
    using std::chrono::microseconds;
    using std::chrono::milliseconds;
    using std::chrono::minutes;
    using std::chrono::months;
    using std::chrono::nanoseconds;
    using std::chrono::seconds;
    using std::chrono::weeks;
    using std::chrono::years;
    using std::chrono::time_point_cast;
    using std::chrono::abs;
    using std::chrono::system_clock;
    using std::chrono::sys_days;
    using std::chrono::sys_seconds;
    using std::chrono::sys_time;
    using std::chrono::file_clock;
    using std::chrono::file_time;
    using std::chrono::steady_clock;
    using std::chrono::high_resolution_clock;
    using std::chrono::local_days;
    using std::chrono::local_seconds;
    using std::chrono::local_t;
    using std::chrono::local_time;
    using std::chrono::last_spec;
    using std::chrono::day;
    using std::chrono::month;
    using std::chrono::year;
    using std::chrono::weekday;
    using std::chrono::weekday_indexed;
    using std::chrono::weekday_last;
    using std::chrono::month_day;
    using std::chrono::month_day_last;
    using std::chrono::month_weekday;
    using std::chrono::month_weekday_last;
    using std::chrono::year_month;
    using std::chrono::year_month_day;
    using std::chrono::year_month_day_last;
    using std::chrono::year_month_weekday;
    using std::chrono::year_month_weekday_last;
    using std::chrono::hh_mm_ss;
    using std::chrono::is_am;
    using std::chrono::is_pm;
    using std::chrono::make12;
    using std::chrono::make24;
  }
  using std::formatter;
  namespace chrono {
    using std::chrono::last;
    using std::chrono::Friday;
    using std::chrono::Monday;
    using std::chrono::Saturday;
    using std::chrono::Sunday;
    using std::chrono::Thursday;
    using std::chrono::Tuesday;
    using std::chrono::Wednesday;
    using std::chrono::April;
    using std::chrono::August;
    using std::chrono::December;
    using std::chrono::February;
    using std::chrono::January;
    using std::chrono::July;
    using std::chrono::June;
    using std::chrono::March;
    using std::chrono::May;
    using std::chrono::November;
    using std::chrono::October;
    using std::chrono::September;
  }
}
export namespace std::inline literals::inline chrono_literals {
  using std::literals::chrono_literals::operator""h;
  using std::literals::chrono_literals::operator""min;
  using std::literals::chrono_literals::operator""s;
  using std::literals::chrono_literals::operator""ms;
  using std::literals::chrono_literals::operator""us;
  using std::literals::chrono_literals::operator""ns;
  using std::literals::chrono_literals::operator""d;
  using std::literals::chrono_literals::operator""y;
}
export namespace std {
  using std::imaxdiv_t __attribute__((__using_if_exists__));
  using std::imaxabs __attribute__((__using_if_exists__));
  using std::imaxdiv __attribute__((__using_if_exists__));
  using std::strtoimax __attribute__((__using_if_exists__));
  using std::strtoumax __attribute__((__using_if_exists__));
  using std::wcstoimax __attribute__((__using_if_exists__));
  using std::wcstoumax __attribute__((__using_if_exists__));
}
export namespace std {
}
export namespace std {
  using std::lconv __attribute__((__using_if_exists__));
  using std::localeconv __attribute__((__using_if_exists__));
  using std::setlocale __attribute__((__using_if_exists__));
}
export namespace std {
  using std::double_t __attribute__((__using_if_exists__));
  using std::float_t __attribute__((__using_if_exists__));
  using std::acos __attribute__((__using_if_exists__));
  using std::acosf __attribute__((__using_if_exists__));
  using std::acosl __attribute__((__using_if_exists__));
  using std::asin __attribute__((__using_if_exists__));
  using std::asinf __attribute__((__using_if_exists__));
  using std::asinl __attribute__((__using_if_exists__));
  using std::atan __attribute__((__using_if_exists__));
  using std::atanf __attribute__((__using_if_exists__));
  using std::atanl __attribute__((__using_if_exists__));
  using std::atan2 __attribute__((__using_if_exists__));
  using std::atan2f __attribute__((__using_if_exists__));
  using std::atan2l __attribute__((__using_if_exists__));
  using std::cos __attribute__((__using_if_exists__));
  using std::cosf __attribute__((__using_if_exists__));
  using std::cosl __attribute__((__using_if_exists__));
  using std::sin __attribute__((__using_if_exists__));
  using std::sinf __attribute__((__using_if_exists__));
  using std::sinl __attribute__((__using_if_exists__));
  using std::tan __attribute__((__using_if_exists__));
  using std::tanf __attribute__((__using_if_exists__));
  using std::tanl __attribute__((__using_if_exists__));
  using std::acosh __attribute__((__using_if_exists__));
  using std::acoshf __attribute__((__using_if_exists__));
  using std::acoshl __attribute__((__using_if_exists__));
  using std::asinh __attribute__((__using_if_exists__));
  using std::asinhf __attribute__((__using_if_exists__));
  using std::asinhl __attribute__((__using_if_exists__));
  using std::atanh __attribute__((__using_if_exists__));
  using std::atanhf __attribute__((__using_if_exists__));
  using std::atanhl __attribute__((__using_if_exists__));
  using std::cosh __attribute__((__using_if_exists__));
  using std::coshf __attribute__((__using_if_exists__));
  using std::coshl __attribute__((__using_if_exists__));
  using std::sinh __attribute__((__using_if_exists__));
  using std::sinhf __attribute__((__using_if_exists__));
  using std::sinhl __attribute__((__using_if_exists__));
  using std::tanh __attribute__((__using_if_exists__));
  using std::tanhf __attribute__((__using_if_exists__));
  using std::tanhl __attribute__((__using_if_exists__));
  using std::exp __attribute__((__using_if_exists__));
  using std::expf __attribute__((__using_if_exists__));
  using std::expl __attribute__((__using_if_exists__));
  using std::exp2 __attribute__((__using_if_exists__));
  using std::exp2f __attribute__((__using_if_exists__));
  using std::exp2l __attribute__((__using_if_exists__));
  using std::expm1 __attribute__((__using_if_exists__));
  using std::expm1f __attribute__((__using_if_exists__));
  using std::expm1l __attribute__((__using_if_exists__));
  using std::frexp __attribute__((__using_if_exists__));
  using std::frexpf __attribute__((__using_if_exists__));
  using std::frexpl __attribute__((__using_if_exists__));
  using std::ilogb __attribute__((__using_if_exists__));
  using std::ilogbf __attribute__((__using_if_exists__));
  using std::ilogbl __attribute__((__using_if_exists__));
  using std::ldexp __attribute__((__using_if_exists__));
  using std::ldexpf __attribute__((__using_if_exists__));
  using std::ldexpl __attribute__((__using_if_exists__));
  using std::log __attribute__((__using_if_exists__));
  using std::logf __attribute__((__using_if_exists__));
  using std::logl __attribute__((__using_if_exists__));
  using std::log10 __attribute__((__using_if_exists__));
  using std::log10f __attribute__((__using_if_exists__));
  using std::log10l __attribute__((__using_if_exists__));
  using std::log1p __attribute__((__using_if_exists__));
  using std::log1pf __attribute__((__using_if_exists__));
  using std::log1pl __attribute__((__using_if_exists__));
  using std::log2 __attribute__((__using_if_exists__));
  using std::log2f __attribute__((__using_if_exists__));
  using std::log2l __attribute__((__using_if_exists__));
  using std::logb __attribute__((__using_if_exists__));
  using std::logbf __attribute__((__using_if_exists__));
  using std::logbl __attribute__((__using_if_exists__));
  using std::modf __attribute__((__using_if_exists__));
  using std::modff __attribute__((__using_if_exists__));
  using std::modfl __attribute__((__using_if_exists__));
  using std::scalbn __attribute__((__using_if_exists__));
  using std::scalbnf __attribute__((__using_if_exists__));
  using std::scalbnl __attribute__((__using_if_exists__));
  using std::scalbln __attribute__((__using_if_exists__));
  using std::scalblnf __attribute__((__using_if_exists__));
  using std::scalblnl __attribute__((__using_if_exists__));
  using std::cbrt __attribute__((__using_if_exists__));
  using std::cbrtf __attribute__((__using_if_exists__));
  using std::cbrtl __attribute__((__using_if_exists__));
  using std::abs __attribute__((__using_if_exists__));
  using std::fabs __attribute__((__using_if_exists__));
  using std::fabsf __attribute__((__using_if_exists__));
  using std::fabsl __attribute__((__using_if_exists__));
  using std::hypot __attribute__((__using_if_exists__));
  using std::hypotf __attribute__((__using_if_exists__));
  using std::hypotl __attribute__((__using_if_exists__));
  using std::pow __attribute__((__using_if_exists__));
  using std::powf __attribute__((__using_if_exists__));
  using std::powl __attribute__((__using_if_exists__));
  using std::sqrt __attribute__((__using_if_exists__));
  using std::sqrtf __attribute__((__using_if_exists__));
  using std::sqrtl __attribute__((__using_if_exists__));
  using std::erf __attribute__((__using_if_exists__));
  using std::erff __attribute__((__using_if_exists__));
  using std::erfl __attribute__((__using_if_exists__));
  using std::erfc __attribute__((__using_if_exists__));
  using std::erfcf __attribute__((__using_if_exists__));
  using std::erfcl __attribute__((__using_if_exists__));
  using std::lgamma __attribute__((__using_if_exists__));
  using std::lgammaf __attribute__((__using_if_exists__));
  using std::lgammal __attribute__((__using_if_exists__));
  using std::tgamma __attribute__((__using_if_exists__));
  using std::tgammaf __attribute__((__using_if_exists__));
  using std::tgammal __attribute__((__using_if_exists__));
  using std::ceil __attribute__((__using_if_exists__));
  using std::ceilf __attribute__((__using_if_exists__));
  using std::ceill __attribute__((__using_if_exists__));
  using std::floor __attribute__((__using_if_exists__));
  using std::floorf __attribute__((__using_if_exists__));
  using std::floorl __attribute__((__using_if_exists__));
  using std::nearbyint __attribute__((__using_if_exists__));
  using std::nearbyintf __attribute__((__using_if_exists__));
  using std::nearbyintl __attribute__((__using_if_exists__));
  using std::rint __attribute__((__using_if_exists__));
  using std::rintf __attribute__((__using_if_exists__));
  using std::rintl __attribute__((__using_if_exists__));
  using std::lrint __attribute__((__using_if_exists__));
  using std::lrintf __attribute__((__using_if_exists__));
  using std::lrintl __attribute__((__using_if_exists__));
  using std::llrint __attribute__((__using_if_exists__));
  using std::llrintf __attribute__((__using_if_exists__));
  using std::llrintl __attribute__((__using_if_exists__));
  using std::round __attribute__((__using_if_exists__));
  using std::roundf __attribute__((__using_if_exists__));
  using std::roundl __attribute__((__using_if_exists__));
  using std::lround __attribute__((__using_if_exists__));
  using std::lroundf __attribute__((__using_if_exists__));
  using std::lroundl __attribute__((__using_if_exists__));
  using std::llround __attribute__((__using_if_exists__));
  using std::llroundf __attribute__((__using_if_exists__));
  using std::llroundl __attribute__((__using_if_exists__));
  using std::trunc __attribute__((__using_if_exists__));
  using std::truncf __attribute__((__using_if_exists__));
  using std::truncl __attribute__((__using_if_exists__));
  using std::fmod __attribute__((__using_if_exists__));
  using std::fmodf __attribute__((__using_if_exists__));
  using std::fmodl __attribute__((__using_if_exists__));
  using std::remainder __attribute__((__using_if_exists__));
  using std::remainderf __attribute__((__using_if_exists__));
  using std::remainderl __attribute__((__using_if_exists__));
  using std::remquo __attribute__((__using_if_exists__));
  using std::remquof __attribute__((__using_if_exists__));
  using std::remquol __attribute__((__using_if_exists__));
  using std::copysign __attribute__((__using_if_exists__));
  using std::copysignf __attribute__((__using_if_exists__));
  using std::copysignl __attribute__((__using_if_exists__));
  using std::nan __attribute__((__using_if_exists__));
  using std::nanf __attribute__((__using_if_exists__));
  using std::nanl __attribute__((__using_if_exists__));
  using std::nextafter __attribute__((__using_if_exists__));
  using std::nextafterf __attribute__((__using_if_exists__));
  using std::nextafterl __attribute__((__using_if_exists__));
  using std::nexttoward __attribute__((__using_if_exists__));
  using std::nexttowardf __attribute__((__using_if_exists__));
  using std::nexttowardl __attribute__((__using_if_exists__));
  using std::fdim __attribute__((__using_if_exists__));
  using std::fdimf __attribute__((__using_if_exists__));
  using std::fdiml __attribute__((__using_if_exists__));
  using std::fmax __attribute__((__using_if_exists__));
  using std::fmaxf __attribute__((__using_if_exists__));
  using std::fmaxl __attribute__((__using_if_exists__));
  using std::fmin __attribute__((__using_if_exists__));
  using std::fminf __attribute__((__using_if_exists__));
  using std::fminl __attribute__((__using_if_exists__));
  using std::fma __attribute__((__using_if_exists__));
  using std::fmaf __attribute__((__using_if_exists__));
  using std::fmal __attribute__((__using_if_exists__));
  using std::lerp __attribute__((__using_if_exists__));
  using std::fpclassify __attribute__((__using_if_exists__));
  using std::isfinite __attribute__((__using_if_exists__));
  using std::isgreater __attribute__((__using_if_exists__));
  using std::isgreaterequal __attribute__((__using_if_exists__));
  using std::isinf __attribute__((__using_if_exists__));
  using std::isless __attribute__((__using_if_exists__));
  using std::islessequal __attribute__((__using_if_exists__));
  using std::islessgreater __attribute__((__using_if_exists__));
  using std::isnan __attribute__((__using_if_exists__));
  using std::isnormal __attribute__((__using_if_exists__));
  using std::isunordered __attribute__((__using_if_exists__));
  using std::signbit __attribute__((__using_if_exists__));
  using std::hermite;
  using std::hermitef;
  using std::hermitel;
}
export namespace std {
}
export namespace std {
  using std::partial_ordering;
  using std::strong_ordering;
  using std::weak_ordering;
  using std::is_eq;
  using std::is_gt;
  using std::is_gteq;
  using std::is_lt;
  using std::is_lteq;
  using std::is_neq;
  using std::common_comparison_category;
  using std::common_comparison_category_t;
  using std::three_way_comparable;
  using std::three_way_comparable_with;
  using std::compare_three_way_result;
  using std::compare_three_way_result_t;
  using std::compare_three_way;
  inline namespace __cpo {
    using std::__cpo::compare_partial_order_fallback;
    using std::__cpo::compare_strong_order_fallback;
    using std::__cpo::compare_weak_order_fallback;
    using std::__cpo::partial_order;
    using std::__cpo::strong_order;
    using std::__cpo::weak_order;
  }
}
export namespace std {
  using std::complex;
  using std::operator+;
  using std::operator-;
  using std::operator*;
  using std::operator/;
  using std::operator==;
  using std::operator>>;
  using std::operator<<;
  using std::imag;
  using std::real;
  using std::abs;
  using std::arg;
  using std::norm;
  using std::conj;
  using std::polar;
  using std::proj;
  using std::acos;
  using std::asin;
  using std::atan;
  using std::acosh;
  using std::asinh;
  using std::atanh;
  using std::cos;
  using std::cosh;
  using std::exp;
  using std::log;
  using std::log10;
  using std::pow;
  using std::sin;
  using std::sinh;
  using std::sqrt;
  using std::tan;
  using std::tanh;
  using std::get;
  using std::tuple_element;
  using std::tuple_size;
  inline namespace literals {
    inline namespace complex_literals {
      using std::operator""il;
      using std::operator""i;
      using std::operator""if;
    }
  }
}
export namespace std {
  using std::same_as;
  using std::derived_from;
  using std::convertible_to;
  using std::common_reference_with;
  using std::common_with;
  using std::floating_point;
  using std::integral;
  using std::signed_integral;
  using std::unsigned_integral;
  using std::assignable_from;
  namespace ranges {
    inline namespace __cpo {
      using std::ranges::__cpo::swap;
    }
  }
  using std::swappable;
  using std::swappable_with;
  using std::destructible;
  using std::constructible_from;
  using std::default_initializable;
  using std::move_constructible;
  using std::copy_constructible;
  using std::equality_comparable;
  using std::equality_comparable_with;
  using std::totally_ordered;
  using std::totally_ordered_with;
  using std::copyable;
  using std::movable;
  using std::regular;
  using std::semiregular;
  using std::invocable;
  using std::regular_invocable;
  using std::predicate;
  using std::relation;
  using std::equivalence_relation;
  using std::strict_weak_order;
}
export namespace std {
  using std::condition_variable;
  using std::condition_variable_any;
  using std::notify_all_at_thread_exit;
  using std::cv_status;
}
export namespace std {
  using std::coroutine_traits;
  using std::coroutine_handle;
  using std::operator==;
  using std::operator<=>;
  using std::hash;
  using std::noop_coroutine;
  using std::noop_coroutine_handle;
  using std::noop_coroutine_promise;
  using std::suspend_always;
  using std::suspend_never;
}
export namespace std {
  using std::jmp_buf __attribute__((__using_if_exists__));
  using std::longjmp __attribute__((__using_if_exists__));
}
export namespace std {
  using std::sig_atomic_t __attribute__((__using_if_exists__));
  using std::signal __attribute__((__using_if_exists__));
  using std::raise __attribute__((__using_if_exists__));
}
export namespace std {
  using std::va_list __attribute__((__using_if_exists__));
}
export namespace std {
  using std::max_align_t __attribute__((__using_if_exists__));
  using std::nullptr_t;
  using std::ptrdiff_t __attribute__((__using_if_exists__));
  using std::size_t __attribute__((__using_if_exists__));
  using std::byte;
  using std::operator<<=;
  using std::operator<<;
  using std::operator>>=;
  using std::operator>>;
  using std::operator|=;
  using std::operator|;
  using std::operator&=;
  using std::operator&;
  using std::operator^=;
  using std::operator^;
  using std::operator~;
  using std::to_integer;
}
export namespace std {
  using std::int8_t __attribute__((__using_if_exists__));
  using std::int16_t __attribute__((__using_if_exists__));
  using std::int32_t __attribute__((__using_if_exists__));
  using std::int64_t __attribute__((__using_if_exists__));
  using std::int_fast16_t __attribute__((__using_if_exists__));
  using std::int_fast32_t __attribute__((__using_if_exists__));
  using std::int_fast64_t __attribute__((__using_if_exists__));
  using std::int_fast8_t __attribute__((__using_if_exists__));
  using std::int_least16_t __attribute__((__using_if_exists__));
  using std::int_least32_t __attribute__((__using_if_exists__));
  using std::int_least64_t __attribute__((__using_if_exists__));
  using std::int_least8_t __attribute__((__using_if_exists__));
  using std::intmax_t __attribute__((__using_if_exists__));
  using std::intptr_t __attribute__((__using_if_exists__));
  using std::uint8_t __attribute__((__using_if_exists__));
  using std::uint16_t __attribute__((__using_if_exists__));
  using std::uint32_t __attribute__((__using_if_exists__));
  using std::uint64_t __attribute__((__using_if_exists__));
  using std::uint_fast16_t __attribute__((__using_if_exists__));
  using std::uint_fast32_t __attribute__((__using_if_exists__));
  using std::uint_fast64_t __attribute__((__using_if_exists__));
  using std::uint_fast8_t __attribute__((__using_if_exists__));
  using std::uint_least16_t __attribute__((__using_if_exists__));
  using std::uint_least32_t __attribute__((__using_if_exists__));
  using std::uint_least64_t __attribute__((__using_if_exists__));
  using std::uint_least8_t __attribute__((__using_if_exists__));
  using std::uintmax_t __attribute__((__using_if_exists__));
  using std::uintptr_t __attribute__((__using_if_exists__));
}
export namespace std {
  using std::FILE __attribute__((__using_if_exists__));
  using std::fpos_t __attribute__((__using_if_exists__));
  using std::size_t __attribute__((__using_if_exists__));
  using std::clearerr __attribute__((__using_if_exists__));
  using std::fclose __attribute__((__using_if_exists__));
  using std::feof __attribute__((__using_if_exists__));
  using std::ferror __attribute__((__using_if_exists__));
  using std::fflush __attribute__((__using_if_exists__));
  using std::fgetc __attribute__((__using_if_exists__));
  using std::fgetpos __attribute__((__using_if_exists__));
  using std::fgets __attribute__((__using_if_exists__));
  using std::fopen __attribute__((__using_if_exists__));
  using std::fprintf __attribute__((__using_if_exists__));
  using std::fputc __attribute__((__using_if_exists__));
  using std::fputs __attribute__((__using_if_exists__));
  using std::fread __attribute__((__using_if_exists__));
  using std::freopen __attribute__((__using_if_exists__));
  using std::fscanf __attribute__((__using_if_exists__));
  using std::fseek __attribute__((__using_if_exists__));
  using std::fsetpos __attribute__((__using_if_exists__));
  using std::ftell __attribute__((__using_if_exists__));
  using std::fwrite __attribute__((__using_if_exists__));
  using std::getc __attribute__((__using_if_exists__));
  using std::getchar __attribute__((__using_if_exists__));
  using std::perror __attribute__((__using_if_exists__));
  using std::printf __attribute__((__using_if_exists__));
  using std::putc __attribute__((__using_if_exists__));
  using std::putchar __attribute__((__using_if_exists__));
  using std::puts __attribute__((__using_if_exists__));
  using std::remove __attribute__((__using_if_exists__));
  using std::rename __attribute__((__using_if_exists__));
  using std::rewind __attribute__((__using_if_exists__));
  using std::scanf __attribute__((__using_if_exists__));
  using std::setbuf __attribute__((__using_if_exists__));
  using std::setvbuf __attribute__((__using_if_exists__));
  using std::snprintf __attribute__((__using_if_exists__));
  using std::sprintf __attribute__((__using_if_exists__));
  using std::sscanf __attribute__((__using_if_exists__));
  using std::tmpfile __attribute__((__using_if_exists__));
  using std::tmpnam __attribute__((__using_if_exists__));
  using std::ungetc __attribute__((__using_if_exists__));
  using std::vfprintf __attribute__((__using_if_exists__));
  using std::vfscanf __attribute__((__using_if_exists__));
  using std::vprintf __attribute__((__using_if_exists__));
  using std::vscanf __attribute__((__using_if_exists__));
  using std::vsnprintf __attribute__((__using_if_exists__));
  using std::vsprintf __attribute__((__using_if_exists__));
  using std::vsscanf __attribute__((__using_if_exists__));
}
export namespace std {
  using std::div_t __attribute__((__using_if_exists__));
  using std::ldiv_t __attribute__((__using_if_exists__));
  using std::lldiv_t __attribute__((__using_if_exists__));
  using std::size_t __attribute__((__using_if_exists__));
  using std::_Exit __attribute__((__using_if_exists__));
  using std::abort __attribute__((__using_if_exists__));
  using std::at_quick_exit __attribute__((__using_if_exists__));
  using std::atexit __attribute__((__using_if_exists__));
  using std::exit __attribute__((__using_if_exists__));
  using std::quick_exit __attribute__((__using_if_exists__));
  using std::getenv __attribute__((__using_if_exists__));
  using std::system __attribute__((__using_if_exists__));
  using std::aligned_alloc __attribute__((__using_if_exists__));
  using std::calloc __attribute__((__using_if_exists__));
  using std::free __attribute__((__using_if_exists__));
  using std::malloc __attribute__((__using_if_exists__));
  using std::realloc __attribute__((__using_if_exists__));
  using std::atof __attribute__((__using_if_exists__));
  using std::atoi __attribute__((__using_if_exists__));
  using std::atol __attribute__((__using_if_exists__));
  using std::atoll __attribute__((__using_if_exists__));
  using std::strtod __attribute__((__using_if_exists__));
  using std::strtof __attribute__((__using_if_exists__));
  using std::strtol __attribute__((__using_if_exists__));
  using std::strtold __attribute__((__using_if_exists__));
  using std::strtoll __attribute__((__using_if_exists__));
  using std::strtoul __attribute__((__using_if_exists__));
  using std::strtoull __attribute__((__using_if_exists__));
  using std::mblen __attribute__((__using_if_exists__));
  using std::mbstowcs __attribute__((__using_if_exists__));
  using std::mbtowc __attribute__((__using_if_exists__));
  using std::wcstombs __attribute__((__using_if_exists__));
  using std::wctomb __attribute__((__using_if_exists__));
  using std::bsearch __attribute__((__using_if_exists__));
  using std::qsort __attribute__((__using_if_exists__));
  using std::rand __attribute__((__using_if_exists__));
  using std::srand __attribute__((__using_if_exists__));
  using std::abs __attribute__((__using_if_exists__));
  using std::labs __attribute__((__using_if_exists__));
  using std::llabs __attribute__((__using_if_exists__));
  using std::div __attribute__((__using_if_exists__));
  using std::ldiv __attribute__((__using_if_exists__));
  using std::lldiv __attribute__((__using_if_exists__));
}
export namespace std {
  using std::size_t __attribute__((__using_if_exists__));
  using std::memchr __attribute__((__using_if_exists__));
  using std::memcmp __attribute__((__using_if_exists__));
  using std::memcpy __attribute__((__using_if_exists__));
  using std::memmove __attribute__((__using_if_exists__));
  using std::memset __attribute__((__using_if_exists__));
  using std::strcat __attribute__((__using_if_exists__));
  using std::strchr __attribute__((__using_if_exists__));
  using std::strcmp __attribute__((__using_if_exists__));
  using std::strcoll __attribute__((__using_if_exists__));
  using std::strcpy __attribute__((__using_if_exists__));
  using std::strcspn __attribute__((__using_if_exists__));
  using std::strerror __attribute__((__using_if_exists__));
  using std::strlen __attribute__((__using_if_exists__));
  using std::strncat __attribute__((__using_if_exists__));
  using std::strncmp __attribute__((__using_if_exists__));
  using std::strncpy __attribute__((__using_if_exists__));
  using std::strpbrk __attribute__((__using_if_exists__));
  using std::strrchr __attribute__((__using_if_exists__));
  using std::strspn __attribute__((__using_if_exists__));
  using std::strstr __attribute__((__using_if_exists__));
  using std::strtok __attribute__((__using_if_exists__));
  using std::strxfrm __attribute__((__using_if_exists__));
}
export namespace std {
  using std::clock_t __attribute__((__using_if_exists__));
  using std::size_t __attribute__((__using_if_exists__));
  using std::time_t __attribute__((__using_if_exists__));
  using std::timespec __attribute__((__using_if_exists__));
  using std::tm __attribute__((__using_if_exists__));
  using std::asctime __attribute__((__using_if_exists__));
  using std::clock __attribute__((__using_if_exists__));
  using std::ctime __attribute__((__using_if_exists__));
  using std::difftime __attribute__((__using_if_exists__));
  using std::gmtime __attribute__((__using_if_exists__));
  using std::localtime __attribute__((__using_if_exists__));
  using std::mktime __attribute__((__using_if_exists__));
  using std::strftime __attribute__((__using_if_exists__));
  using std::time __attribute__((__using_if_exists__));
  using std::timespec_get __attribute__((__using_if_exists__));
}
export namespace std {
  using std::mbrtoc16 __attribute__((__using_if_exists__));
  using std::c16rtomb __attribute__((__using_if_exists__));
  using std::mbrtoc32 __attribute__((__using_if_exists__));
  using std::c32rtomb __attribute__((__using_if_exists__));
}
export namespace std {
  using std::mbstate_t __attribute__((__using_if_exists__));
  using std::size_t __attribute__((__using_if_exists__));
  using std::wint_t __attribute__((__using_if_exists__));
  using std::tm __attribute__((__using_if_exists__));
  using std::btowc __attribute__((__using_if_exists__));
  using std::fgetwc __attribute__((__using_if_exists__));
  using std::fgetws __attribute__((__using_if_exists__));
  using std::fputwc __attribute__((__using_if_exists__));
  using std::fputws __attribute__((__using_if_exists__));
  using std::fwide __attribute__((__using_if_exists__));
  using std::fwprintf __attribute__((__using_if_exists__));
  using std::fwscanf __attribute__((__using_if_exists__));
  using std::getwc __attribute__((__using_if_exists__));
  using std::getwchar __attribute__((__using_if_exists__));
  using std::putwc __attribute__((__using_if_exists__));
  using std::putwchar __attribute__((__using_if_exists__));
  using std::swprintf __attribute__((__using_if_exists__));
  using std::swscanf __attribute__((__using_if_exists__));
  using std::ungetwc __attribute__((__using_if_exists__));
  using std::vfwprintf __attribute__((__using_if_exists__));
  using std::vfwscanf __attribute__((__using_if_exists__));
  using std::vswprintf __attribute__((__using_if_exists__));
  using std::vswscanf __attribute__((__using_if_exists__));
  using std::vwprintf __attribute__((__using_if_exists__));
  using std::vwscanf __attribute__((__using_if_exists__));
  using std::wcscat __attribute__((__using_if_exists__));
  using std::wcschr __attribute__((__using_if_exists__));
  using std::wcscmp __attribute__((__using_if_exists__));
  using std::wcscoll __attribute__((__using_if_exists__));
  using std::wcscpy __attribute__((__using_if_exists__));
  using std::wcscspn __attribute__((__using_if_exists__));
  using std::wcsftime __attribute__((__using_if_exists__));
  using std::wcslen __attribute__((__using_if_exists__));
  using std::wcsncat __attribute__((__using_if_exists__));
  using std::wcsncmp __attribute__((__using_if_exists__));
  using std::wcsncpy __attribute__((__using_if_exists__));
  using std::wcspbrk __attribute__((__using_if_exists__));
  using std::wcsrchr __attribute__((__using_if_exists__));
  using std::wcsspn __attribute__((__using_if_exists__));
  using std::wcsstr __attribute__((__using_if_exists__));
  using std::wcstod __attribute__((__using_if_exists__));
  using std::wcstof __attribute__((__using_if_exists__));
  using std::wcstok __attribute__((__using_if_exists__));
  using std::wcstol __attribute__((__using_if_exists__));
  using std::wcstold __attribute__((__using_if_exists__));
  using std::wcstoll __attribute__((__using_if_exists__));
  using std::wcstoul __attribute__((__using_if_exists__));
  using std::wcstoull __attribute__((__using_if_exists__));
  using std::wcsxfrm __attribute__((__using_if_exists__));
  using std::wctob __attribute__((__using_if_exists__));
  using std::wmemchr __attribute__((__using_if_exists__));
  using std::wmemcmp __attribute__((__using_if_exists__));
  using std::wmemcpy __attribute__((__using_if_exists__));
  using std::wmemmove __attribute__((__using_if_exists__));
  using std::wmemset __attribute__((__using_if_exists__));
  using std::wprintf __attribute__((__using_if_exists__));
  using std::wscanf __attribute__((__using_if_exists__));
  using std::mbrlen __attribute__((__using_if_exists__));
  using std::mbrtowc __attribute__((__using_if_exists__));
  using std::mbsinit __attribute__((__using_if_exists__));
  using std::mbsrtowcs __attribute__((__using_if_exists__));
  using std::wcrtomb __attribute__((__using_if_exists__));
  using std::wcsrtombs __attribute__((__using_if_exists__));
}
export namespace std {
  using std::wctrans_t __attribute__((__using_if_exists__));
  using std::wctype_t __attribute__((__using_if_exists__));
  using std::wint_t __attribute__((__using_if_exists__));
  using std::iswalnum __attribute__((__using_if_exists__));
  using std::iswalpha __attribute__((__using_if_exists__));
  using std::iswblank __attribute__((__using_if_exists__));
  using std::iswcntrl __attribute__((__using_if_exists__));
  using std::iswctype __attribute__((__using_if_exists__));
  using std::iswdigit __attribute__((__using_if_exists__));
  using std::iswgraph __attribute__((__using_if_exists__));
  using std::iswlower __attribute__((__using_if_exists__));
  using std::iswprint __attribute__((__using_if_exists__));
  using std::iswpunct __attribute__((__using_if_exists__));
  using std::iswspace __attribute__((__using_if_exists__));
  using std::iswupper __attribute__((__using_if_exists__));
  using std::iswxdigit __attribute__((__using_if_exists__));
  using std::towctrans __attribute__((__using_if_exists__));
  using std::towlower __attribute__((__using_if_exists__));
  using std::towupper __attribute__((__using_if_exists__));
  using std::wctrans __attribute__((__using_if_exists__));
  using std::wctype __attribute__((__using_if_exists__));
}
export namespace std {
  using std::deque;
  using std::operator==;
  using std::operator<=>;
  using std::swap;
  using std::erase;
  using std::erase_if;
  namespace pmr {
    using std::pmr::deque;
  }
}
export namespace std {
  using std::bad_exception;
  using std::current_exception;
  using std::exception;
  using std::exception_ptr;
  using std::get_terminate;
  using std::make_exception_ptr;
  using std::nested_exception;
  using std::rethrow_exception;
  using std::rethrow_if_nested;
  using std::set_terminate;
  using std::terminate;
  using std::terminate_handler;
  using std::throw_with_nested;
  using std::uncaught_exceptions;
}
export namespace std {
  using std::unexpected;
  using std::bad_expected_access;
  using std::unexpect;
  using std::unexpect_t;
  using std::expected;
}
export namespace std::filesystem {
  using std::filesystem::path;
  using std::filesystem::hash_value;
  using std::filesystem::swap;
  using std::filesystem::filesystem_error;
  using std::filesystem::directory_entry;
  using std::filesystem::directory_iterator;
  using std::filesystem::begin;
  using std::filesystem::end;
  using std::filesystem::recursive_directory_iterator;
  using std::filesystem::file_status;
  using std::filesystem::space_info;
  using std::filesystem::copy_options;
  using std::filesystem::directory_options;
  using std::filesystem::file_type;
  using std::filesystem::perm_options;
  using std::filesystem::perms;
  using std::filesystem::file_time_type;
  using std::filesystem::operator&;
  using std::filesystem::operator&=;
  using std::filesystem::operator^;
  using std::filesystem::operator^=;
  using std::filesystem::operator|;
  using std::filesystem::operator|=;
  using std::filesystem::operator~;
  using std::filesystem::absolute;
  using std::filesystem::canonical;
  using std::filesystem::copy;
  using std::filesystem::copy_file;
  using std::filesystem::copy_symlink;
  using std::filesystem::create_directories;
  using std::filesystem::create_directory;
  using std::filesystem::create_directory_symlink;
  using std::filesystem::create_hard_link;
  using std::filesystem::create_symlink;
  using std::filesystem::current_path;
  using std::filesystem::equivalent;
  using std::filesystem::exists;
  using std::filesystem::file_size;
  using std::filesystem::hard_link_count;
  using std::filesystem::is_block_file;
  using std::filesystem::is_character_file;
  using std::filesystem::is_directory;
  using std::filesystem::is_empty;
  using std::filesystem::is_fifo;
  using std::filesystem::is_other;
  using std::filesystem::is_regular_file;
  using std::filesystem::is_socket;
  using std::filesystem::is_symlink;
  using std::filesystem::last_write_time;
  using std::filesystem::permissions;
  using std::filesystem::proximate;
  using std::filesystem::read_symlink;
  using std::filesystem::relative;
  using std::filesystem::remove;
  using std::filesystem::remove_all;
  using std::filesystem::rename;
  using std::filesystem::resize_file;
  using std::filesystem::space;
  using std::filesystem::status;
  using std::filesystem::status_known;
  using std::filesystem::symlink_status;
  using std::filesystem::temp_directory_path;
  using std::filesystem::weakly_canonical;
  using std::filesystem::u8path;
}
export namespace std {
  using std::hash;
}
export namespace std::ranges {
  using std::ranges::enable_borrowed_range;
  using std::ranges::enable_view;
}
export namespace std {
  using std::flat_map;
  using std::sorted_unique;
  using std::sorted_unique_t;
  using std::uses_allocator;
  using std::erase_if;
  using std::flat_multimap;
  using std::sorted_equivalent;
  using std::sorted_equivalent_t;
}
export namespace std {
}
export namespace std {
  using std::basic_format_context;
  using std::format_context;
  using std::wformat_context;
  using std::basic_format_args;
  using std::format_args;
  using std::wformat_args;
  using std::basic_format_string;
  using std::format_string;
  using std::wformat_string;
  using std::runtime_format;
  using std::format;
  using std::format_to;
  using std::vformat;
  using std::vformat_to;
  using std::format_to_n;
  using std::format_to_n_result;
  using std::formatted_size;
  using std::formatter;
  using std::enable_nonlocking_formatter_optimization;
  using std::formattable;
  using std::basic_format_parse_context;
  using std::format_parse_context;
  using std::wformat_parse_context;
  using std::format_kind;
  using std::range_format;
  using std::range_formatter;
  using std::basic_format_arg;
  using std::visit_format_arg;
  using std::make_format_args;
  using std::make_wformat_args;
  using std::format_error;
}
export namespace std {
  using std::forward_list;
  using std::operator==;
  using std::operator<=>;
  using std::swap;
  using std::erase;
  using std::erase_if;
  namespace pmr {
    using std::pmr::forward_list;
  }
}
export namespace std {
  using std::basic_filebuf;
  using std::swap;
  using std::filebuf;
  using std::wfilebuf;
  using std::basic_ifstream;
  using std::ifstream;
  using std::wifstream;
  using std::basic_ofstream;
  using std::ofstream;
  using std::wofstream;
  using std::basic_fstream;
  using std::fstream;
  using std::wfstream;
}
export namespace std {
  using std::invoke;
  using std::invoke_r;
  using std::reference_wrapper;
  using std::cref;
  using std::ref;
  using std::divides;
  using std::minus;
  using std::modulus;
  using std::multiplies;
  using std::negate;
  using std::plus;
  using std::equal_to;
  using std::greater;
  using std::greater_equal;
  using std::less;
  using std::less_equal;
  using std::not_equal_to;
  using std::compare_three_way;
  using std::logical_and;
  using std::logical_not;
  using std::logical_or;
  using std::bit_and;
  using std::bit_not;
  using std::bit_or;
  using std::bit_xor;
  using std::identity;
  using std::not_fn;
  using std::bind_front;
  using std::bind_back;
  using std::is_bind_expression;
  using std::is_bind_expression_v;
  using std::is_placeholder;
  using std::is_placeholder_v;
  using std::bind;
  namespace placeholders {
    using std::placeholders::_1;
    using std::placeholders::_10;
    using std::placeholders::_2;
    using std::placeholders::_3;
    using std::placeholders::_4;
    using std::placeholders::_5;
    using std::placeholders::_6;
    using std::placeholders::_7;
    using std::placeholders::_8;
    using std::placeholders::_9;
  }
  using std::mem_fn;
  using std::bad_function_call;
  using std::function;
  using std::swap;
  using std::operator==;
  using std::default_searcher;
  using std::boyer_moore_searcher;
  using std::boyer_moore_horspool_searcher;
  using std::hash;
  namespace ranges {
    using std::ranges::equal_to;
    using std::ranges::greater;
    using std::ranges::greater_equal;
    using std::ranges::less;
    using std::ranges::less_equal;
    using std::ranges::not_equal_to;
  }
}
export namespace std {
  using std::future_errc;
  using std::future_status;
  using std::launch;
  using std::operator&;
  using std::operator&=;
  using std::operator^;
  using std::operator^=;
  using std::operator|;
  using std::operator|=;
  using std::operator~;
  using std::is_error_code_enum;
  using std::make_error_code;
  using std::make_error_condition;
  using std::future_category;
  using std::future_error;
  using std::promise;
  using std::swap;
  using std::uses_allocator;
  using std::future;
  using std::shared_future;
  using std::packaged_task;
  using std::async;
}
export namespace std {
}
export namespace std {
}
export namespace std {
  using std::initializer_list;
  using std::begin;
  using std::end;
}
export namespace std {
  using std::get_money;
  using std::get_time;
  using std::put_money;
  using std::put_time;
  using std::resetiosflags;
  using std::setbase;
  using std::setfill;
  using std::setiosflags;
  using std::setprecision;
  using std::setw;
  using std::quoted;
}
export namespace std {
  using std::fpos;
  using std::operator!=;
  using std::operator-;
  using std::operator==;
  using std::streamoff;
  using std::streamsize;
  using std::basic_ios;
  using std::ios_base;
  using std::boolalpha;
  using std::noboolalpha;
  using std::noshowbase;
  using std::showbase;
  using std::noshowpoint;
  using std::showpoint;
  using std::noshowpos;
  using std::showpos;
  using std::noskipws;
  using std::skipws;
  using std::nouppercase;
  using std::uppercase;
  using std::nounitbuf;
  using std::unitbuf;
  using std::internal;
  using std::left;
  using std::right;
  using std::dec;
  using std::hex;
  using std::oct;
  using std::defaultfloat;
  using std::fixed;
  using std::hexfloat;
  using std::scientific;
  using std::io_errc;
  using std::iostream_category;
  using std::is_error_code_enum;
  using std::make_error_code;
  using std::make_error_condition;
  using std::ios;
  using std::wios;
}
export namespace std {
  using std::streampos;
  using std::wstreampos;
  using std::u16streampos;
  using std::u32streampos;
  using std::u8streampos;
  using std::istreambuf_iterator;
  using std::ostreambuf_iterator;
  using std::fpos;
}
export namespace std {
  using std::cerr;
  using std::cin;
  using std::clog;
  using std::cout;
  using std::wcerr;
  using std::wcin;
  using std::wclog;
  using std::wcout;
}
export namespace std {
  using std::basic_istream;
  using std::istream;
  using std::wistream;
  using std::basic_iostream;
  using std::iostream;
  using std::wiostream;
  using std::ws;
  using std::operator>>;
}
export namespace std {
  using std::incrementable_traits;
  using std::iter_difference_t;
  using std::indirectly_readable_traits;
  using std::iter_value_t;
  using std::iterator_traits;
  using std::iter_reference_t;
  namespace ranges {
    inline namespace __cpo {
      using std::ranges::__cpo::iter_move;
      using std::ranges::__cpo::iter_swap;
    }
  }
  using std::iter_rvalue_reference_t;
  using std::indirectly_readable;
  using std::iter_common_reference_t;
  using std::indirectly_writable;
  using std::weakly_incrementable;
  using std::incrementable;
  using std::input_or_output_iterator;
  using std::sentinel_for;
  using std::disable_sized_sentinel_for;
  using std::sized_sentinel_for;
  using std::input_iterator;
  using std::output_iterator;
  using std::forward_iterator;
  using std::bidirectional_iterator;
  using std::random_access_iterator;
  using std::contiguous_iterator;
  using std::indirectly_unary_invocable;
  using std::indirectly_regular_unary_invocable;
  using std::indirect_unary_predicate;
  using std::indirect_binary_predicate;
  using std::indirect_equivalence_relation;
  using std::indirect_strict_weak_order;
  using std::indirect_result_t;
  using std::projected;
  using std::indirectly_movable;
  using std::indirectly_movable_storable;
  using std::indirectly_copyable;
  using std::indirectly_copyable_storable;
  using std::indirectly_swappable;
  using std::indirectly_comparable;
  using std::permutable;
  using std::mergeable;
  using std::sortable;
  using std::bidirectional_iterator_tag;
  using std::contiguous_iterator_tag;
  using std::forward_iterator_tag;
  using std::input_iterator_tag;
  using std::output_iterator_tag;
  using std::random_access_iterator_tag;
  using std::advance;
  using std::distance;
  using std::next;
  using std::prev;
  namespace ranges {
    using std::ranges::advance;
    using std::ranges::distance;
    using std::ranges::next;
    using std::ranges::prev;
  }
  using std::reverse_iterator;
  using std::operator==;
  using std::operator!=;
  using std::operator<;
  using std::operator>;
  using std::operator<=;
  using std::operator>=;
  using std::operator<=>;
  using std::operator-;
  using std::operator+;
  using std::make_reverse_iterator;
  using std::back_insert_iterator;
  using std::back_inserter;
  using std::front_insert_iterator;
  using std::front_inserter;
  using std::insert_iterator;
  using std::inserter;
  using std::move_iterator;
  using std::make_move_iterator;
  using std::move_sentinel;
  using std::common_iterator;
  using std::default_sentinel;
  using std::default_sentinel_t;
  using std::counted_iterator;
  using std::unreachable_sentinel;
  using std::unreachable_sentinel_t;
  using std::istream_iterator;
  using std::ostream_iterator;
  using std::istreambuf_iterator;
  using std::ostreambuf_iterator;
  using std::begin;
  using std::cbegin;
  using std::cend;
  using std::crbegin;
  using std::crend;
  using std::end;
  using std::rbegin;
  using std::rend;
  using std::empty;
  using std::size;
  using std::ssize;
  using std::data;
  using std::iterator;
}
export namespace std {
  using std::latch;
}
export namespace std {
  using std::float_denorm_style;
  using std::float_round_style;
  using std::numeric_limits;
}
export namespace std {
  using std::list;
  using std::operator==;
  using std::operator<=>;
  using std::swap;
  using std::erase;
  using std::erase_if;
  namespace pmr {
    using std::pmr::list;
  }
}
export namespace std {
  using std::has_facet;
  using std::locale;
  using std::use_facet;
  using std::isalnum;
  using std::isalpha;
  using std::isblank;
  using std::iscntrl;
  using std::isdigit;
  using std::isgraph;
  using std::islower;
  using std::isprint;
  using std::ispunct;
  using std::isspace;
  using std::isupper;
  using std::isxdigit;
  using std::tolower;
  using std::toupper;
  using std::codecvt;
  using std::codecvt_base;
  using std::codecvt_byname;
  using std::ctype;
  using std::ctype_base;
  using std::ctype_byname;
  using std::num_get;
  using std::num_put;
  using std::numpunct;
  using std::numpunct_byname;
  using std::collate;
  using std::collate_byname;
  using std::time_base;
  using std::time_get;
  using std::time_get_byname;
  using std::time_put;
  using std::time_put_byname;
  using std::money_base;
  using std::money_get;
  using std::money_put;
  using std::moneypunct;
  using std::moneypunct_byname;
  using std::messages;
  using std::messages_base;
  using std::messages_byname;
}
export namespace std {
  using std::map;
  using std::operator==;
  using std::operator<=>;
  using std::swap;
  using std::erase_if;
  using std::multimap;
  namespace pmr {
    using std::pmr::map;
    using std::pmr::multimap;
  }
}
export namespace std {
  using std::extents;
  using std::dextents;
  using std::dims;
  using std::layout_left;
  using std::layout_right;
  using std::layout_stride;
  using std::default_accessor;
  using std::mdspan;
}
export namespace std {
  using std::pointer_traits;
  using std::to_address;
  using std::align;
  using std::assume_aligned;
  using std::allocator_arg;
  using std::allocator_arg_t;
  using std::uses_allocator;
  using std::uses_allocator_v;
  using std::uses_allocator_construction_args;
  using std::make_obj_using_allocator;
  using std::uninitialized_construct_using_allocator;
  using std::allocator_traits;
  using std::allocation_result;
  using std::allocator;
  using std::operator==;
  using std::addressof;
  using std::uninitialized_default_construct;
  using std::uninitialized_default_construct_n;
  namespace ranges {
    using std::ranges::uninitialized_default_construct;
    using std::ranges::uninitialized_default_construct_n;
  }
  using std::uninitialized_value_construct;
  using std::uninitialized_value_construct_n;
  namespace ranges {
    using std::ranges::uninitialized_value_construct;
    using std::ranges::uninitialized_value_construct_n;
  }
  using std::uninitialized_copy;
  using std::uninitialized_copy_n;
  namespace ranges {
    using std::ranges::uninitialized_copy;
    using std::ranges::uninitialized_copy_result;
    using std::ranges::uninitialized_copy_n;
    using std::ranges::uninitialized_copy_n_result;
  }
  using std::uninitialized_move;
  using std::uninitialized_move_n;
  namespace ranges {
    using std::ranges::uninitialized_move;
    using std::ranges::uninitialized_move_result;
    using std::ranges::uninitialized_move_n;
    using std::ranges::uninitialized_move_n_result;
  }
  using std::uninitialized_fill;
  using std::uninitialized_fill_n;
  namespace ranges {
    using std::ranges::uninitialized_fill;
    using std::ranges::uninitialized_fill_n;
  }
  using std::construct_at;
  namespace ranges {
    using std::ranges::construct_at;
  }
  using std::destroy;
  using std::destroy_at;
  using std::destroy_n;
  namespace ranges {
    using std::ranges::destroy;
    using std::ranges::destroy_at;
    using std::ranges::destroy_n;
  }
  using std::default_delete;
  using std::unique_ptr;
  using std::make_unique;
  using std::make_unique_for_overwrite;
  using std::operator<;
  using std::operator>;
  using std::operator<=;
  using std::operator>=;
  using std::operator<=>;
  using std::operator<<;
  using std::bad_weak_ptr;
  using std::shared_ptr;
  using std::allocate_shared;
  using std::allocate_shared_for_overwrite;
  using std::make_shared;
  using std::make_shared_for_overwrite;
  using std::swap;
  using std::const_pointer_cast;
  using std::dynamic_pointer_cast;
  using std::reinterpret_pointer_cast;
  using std::static_pointer_cast;
  using std::get_deleter;
  using std::weak_ptr;
  using std::owner_less;
  using std::enable_shared_from_this;
  using std::hash;
  using std::out_ptr_t;
  using std::out_ptr;
  using std::inout_ptr_t;
  using std::inout_ptr;
  using std::atomic_is_lock_free;
  using std::atomic_load;
  using std::atomic_load_explicit;
  using std::atomic_store;
  using std::atomic_store_explicit;
  using std::atomic_exchange;
  using std::atomic_exchange_explicit;
  using std::atomic_compare_exchange_strong;
  using std::atomic_compare_exchange_strong_explicit;
  using std::atomic_compare_exchange_weak;
  using std::atomic_compare_exchange_weak_explicit;
}
export namespace std::pmr {
  using std::pmr::memory_resource;
  using std::pmr::operator==;
  using std::pmr::polymorphic_allocator;
  using std::pmr::get_default_resource;
  using std::pmr::new_delete_resource;
  using std::pmr::null_memory_resource;
  using std::pmr::set_default_resource;
  using std::pmr::monotonic_buffer_resource;
  using std::pmr::pool_options;
  using std::pmr::synchronized_pool_resource;
  using std::pmr::unsynchronized_pool_resource;
}
export namespace std {
  using std::mutex;
  using std::recursive_mutex;
  using std::timed_mutex;
  using std::recursive_timed_mutex;
  using std::adopt_lock_t;
  using std::defer_lock_t;
  using std::try_to_lock_t;
  using std::adopt_lock;
  using std::defer_lock;
  using std::try_to_lock;
  using std::lock_guard;
  using std::scoped_lock;
  using std::unique_lock;
  using std::swap;
  using std::lock;
  using std::try_lock;
  using std::once_flag;
  using std::call_once;
}
export namespace std {
  using std::bad_alloc;
  using std::bad_array_new_length;
  using std::destroying_delete;
  using std::destroying_delete_t;
  using std::align_val_t;
  using std::nothrow;
  using std::nothrow_t;
  using std::get_new_handler;
  using std::new_handler;
  using std::set_new_handler;
  using std::launder;
  using std::hardware_constructive_interference_size;
  using std::hardware_destructive_interference_size;
}
export {
  using ::operator new;
  using ::operator delete;
  using ::operator new[];
  using ::operator delete[];
}
export namespace std::numbers {
  using std::numbers::e_v;
  using std::numbers::egamma_v;
  using std::numbers::inv_pi_v;
  using std::numbers::inv_sqrt3_v;
  using std::numbers::inv_sqrtpi_v;
  using std::numbers::ln10_v;
  using std::numbers::ln2_v;
  using std::numbers::log10e_v;
  using std::numbers::log2e_v;
  using std::numbers::phi_v;
  using std::numbers::pi_v;
  using std::numbers::sqrt2_v;
  using std::numbers::sqrt3_v;
  using std::numbers::e;
  using std::numbers::egamma;
  using std::numbers::inv_pi;
  using std::numbers::inv_sqrt3;
  using std::numbers::inv_sqrtpi;
  using std::numbers::ln10;
  using std::numbers::ln2;
  using std::numbers::log10e;
  using std::numbers::log2e;
  using std::numbers::phi;
  using std::numbers::pi;
  using std::numbers::sqrt2;
  using std::numbers::sqrt3;
}
export namespace std {
  using std::accumulate;
  using std::reduce;
  using std::inner_product;
  using std::transform_reduce;
  using std::partial_sum;
  using std::exclusive_scan;
  using std::inclusive_scan;
  using std::transform_exclusive_scan;
  using std::transform_inclusive_scan;
  using std::adjacent_difference;
  using std::iota;
  namespace ranges {
  }
  using std::gcd;
  using std::lcm;
  using std::midpoint;
  using std::add_sat;
  using std::div_sat;
  using std::mul_sat;
  using std::saturate_cast;
  using std::sub_sat;
}
export namespace std {
  using std::optional;
  using std::nullopt;
  using std::nullopt_t;
  using std::bad_optional_access;
  using std::operator==;
  using std::operator!=;
  using std::operator<;
  using std::operator>;
  using std::operator<=;
  using std::operator>=;
  using std::operator<=>;
  using std::swap;
  using std::make_optional;
  using std::hash;
}
export namespace std {
  using std::basic_ostream;
  using std::ostream;
  using std::wostream;
  using std::endl;
  using std::ends;
  using std::flush;
  using std::operator<<;
  using std::print;
  using std::println;
  using std::vprint_nonunicode;
  using std::vprint_unicode;
}
export namespace std {
  using std::print;
  using std::println;
  using std::vprint_nonunicode;
  using std::vprint_unicode;
}
export namespace std {
  using std::queue;
  using std::operator==;
  using std::operator!=;
  using std::operator<;
  using std::operator>;
  using std::operator<=;
  using std::operator>=;
  using std::operator<=>;
  using std::swap;
  using std::uses_allocator;
  using std::priority_queue;
}
export namespace std {
  using std::uniform_random_bit_generator;
  using std::linear_congruential_engine;
  using std::mersenne_twister_engine;
  using std::subtract_with_carry_engine;
  using std::discard_block_engine;
  using std::independent_bits_engine;
  using std::shuffle_order_engine;
  using std::knuth_b;
  using std::minstd_rand;
  using std::minstd_rand0;
  using std::mt19937;
  using std::mt19937_64;
  using std::ranlux24;
  using std::ranlux24_base;
  using std::ranlux48;
  using std::ranlux48_base;
  using std::default_random_engine;
  using std::random_device;
  using std::seed_seq;
  using std::generate_canonical;
  using std::uniform_int_distribution;
  using std::uniform_real_distribution;
  using std::bernoulli_distribution;
  using std::binomial_distribution;
  using std::geometric_distribution;
  using std::negative_binomial_distribution;
  using std::poisson_distribution;
  using std::exponential_distribution;
  using std::gamma_distribution;
  using std::weibull_distribution;
  using std::extreme_value_distribution;
  using std::normal_distribution;
  using std::lognormal_distribution;
  using std::chi_squared_distribution;
  using std::cauchy_distribution;
  using std::fisher_f_distribution;
  using std::student_t_distribution;
  using std::discrete_distribution;
  using std::piecewise_constant_distribution;
  using std::piecewise_linear_distribution;
}
export namespace std {
  namespace ranges {
    inline namespace __cpo {
      using std::ranges::__cpo::begin;
      using std::ranges::__cpo::cbegin;
      using std::ranges::__cpo::cend;
      using std::ranges::__cpo::crbegin;
      using std::ranges::__cpo::crend;
      using std::ranges::__cpo::end;
      using std::ranges::__cpo::rbegin;
      using std::ranges::__cpo::rend;
      using std::ranges::__cpo::cdata;
      using std::ranges::__cpo::data;
      using std::ranges::__cpo::empty;
      using std::ranges::__cpo::size;
      using std::ranges::__cpo::ssize;
    }
    using std::ranges::range;
    using std::ranges::enable_borrowed_range;
    using std::ranges::borrowed_range;
    using std::ranges::iterator_t;
    using std::ranges::range_common_reference_t;
    using std::ranges::range_difference_t;
    using std::ranges::range_reference_t;
    using std::ranges::range_rvalue_reference_t;
    using std::ranges::range_size_t;
    using std::ranges::range_value_t;
    using std::ranges::sentinel_t;
    using std::ranges::disable_sized_range;
    using std::ranges::sized_range;
    using std::ranges::enable_view;
    using std::ranges::view;
    using std::ranges::view_base;
    using std::ranges::bidirectional_range;
    using std::ranges::common_range;
    using std::ranges::contiguous_range;
    using std::ranges::forward_range;
    using std::ranges::input_range;
    using std::ranges::output_range;
    using std::ranges::random_access_range;
    using std::ranges::viewable_range;
    using std::ranges::view_interface;
    using std::ranges::subrange;
    using std::ranges::subrange_kind;
    using std::ranges::get;
  }
  using std::ranges::get;
  namespace ranges {
    using std::ranges::dangling;
    using std::ranges::borrowed_iterator_t;
    using std::ranges::borrowed_subrange_t;
    using std::ranges::to;
    using std::ranges::empty_view;
    namespace views {
      using std::ranges::views::empty;
    }
    using std::ranges::single_view;
    namespace views {
      using std::ranges::views::single;
    }
    using std::ranges::iota_view;
    namespace views {
      using std::ranges::views::iota;
    }
    using std::ranges::repeat_view;
    namespace views {
      using std::ranges::views::repeat;
    }
    using std::ranges::basic_istream_view;
    using std::ranges::istream_view;
    using std::ranges::wistream_view;
    namespace views {
      using std::ranges::views::istream;
    }
    using std::ranges::operator|;
    using std::ranges::range_adaptor_closure;
    namespace views {
      using std::ranges::views::all;
      using std::ranges::views::all_t;
    }
    using std::ranges::ref_view;
    using std::ranges::owning_view;
    using std::ranges::as_rvalue_view;
    namespace views {
      using std::ranges::views::as_rvalue;
    }
    using std::ranges::filter_view;
    namespace views {
      using std::ranges::views::filter;
    }
    using std::ranges::transform_view;
    namespace views {
      using std::ranges::views::transform;
    }
    using std::ranges::take_view;
    namespace views {
      using std::ranges::views::take;
    }
    using std::ranges::take_while_view;
    namespace views {
      using std::ranges::views::take_while;
    }
    using std::ranges::drop_view;
    namespace views {
      using std::ranges::views::drop;
    }
    using std::ranges::drop_while_view;
    namespace views {
      using std::ranges::views::drop_while;
    }
    using std::ranges::join_view;
    namespace views {
      using std::ranges::views::join;
    }
    using std::ranges::lazy_split_view;
    using std::ranges::split_view;
    namespace views {
      using std::ranges::views::lazy_split;
      using std::ranges::views::split;
    }
    namespace views {
      using std::ranges::views::counted;
    }
    using std::ranges::common_view;
    namespace views {
      using std::ranges::views::common;
    }
    using std::ranges::reverse_view;
    namespace views {
      using std::ranges::views::reverse;
    }
    using std::ranges::elements_view;
    using std::ranges::keys_view;
    using std::ranges::values_view;
    namespace views {
      using std::ranges::views::elements;
      using std::ranges::views::keys;
      using std::ranges::views::values;
    }
    using std::ranges::zip_view;
    namespace views {
      using std::ranges::views::zip;
    }
    using std::ranges::chunk_by_view;
    namespace views {
      using std::ranges::views::chunk_by;
    }
  }
  namespace views = ranges::views;
  using std::tuple_element;
  using std::tuple_size;
  using std::from_range;
  using std::from_range_t;
}
export namespace std {
  using std::ratio;
  using std::ratio_add;
  using std::ratio_divide;
  using std::ratio_multiply;
  using std::ratio_subtract;
  using std::ratio_equal;
  using std::ratio_greater;
  using std::ratio_greater_equal;
  using std::ratio_less;
  using std::ratio_less_equal;
  using std::ratio_not_equal;
  using std::ratio_equal_v;
  using std::ratio_greater_equal_v;
  using std::ratio_greater_v;
  using std::ratio_less_equal_v;
  using std::ratio_less_v;
  using std::ratio_not_equal_v;
  using std::atto;
  using std::centi;
  using std::deca;
  using std::deci;
  using std::exa;
  using std::femto;
  using std::giga;
  using std::hecto;
  using std::kilo;
  using std::mega;
  using std::micro;
  using std::milli;
  using std::nano;
  using std::peta;
  using std::pico;
  using std::tera;
}
export namespace std {
}
export namespace std {
  namespace regex_constants {
    using std::regex_constants::error_type;
    using std::regex_constants::match_flag_type;
    using std::regex_constants::syntax_option_type;
    using std::regex_constants::operator&;
    using std::regex_constants::operator&=;
    using std::regex_constants::operator^;
    using std::regex_constants::operator^=;
    using std::regex_constants::operator|;
    using std::regex_constants::operator|=;
    using std::regex_constants::operator~;
  }
  using std::regex_error;
  using std::regex_traits;
  using std::basic_regex;
  using std::regex;
  using std::wregex;
  using std::swap;
  using std::sub_match;
  using std::csub_match;
  using std::ssub_match;
  using std::wcsub_match;
  using std::wssub_match;
  using std::operator==;
  using std::operator<=>;
  using std::operator<<;
  using std::match_results;
  using std::cmatch;
  using std::smatch;
  using std::wcmatch;
  using std::wsmatch;
  using std::regex_match;
  using std::regex_search;
  using std::regex_replace;
  using std::regex_iterator;
  using std::cregex_iterator;
  using std::sregex_iterator;
  using std::wcregex_iterator;
  using std::wsregex_iterator;
  using std::regex_token_iterator;
  using std::cregex_token_iterator;
  using std::sregex_token_iterator;
  using std::wcregex_token_iterator;
  using std::wsregex_token_iterator;
  namespace pmr {
    using std::pmr::match_results;
    using std::pmr::cmatch;
    using std::pmr::smatch;
    using std::pmr::wcmatch;
    using std::pmr::wsmatch;
  }
}
export namespace std {
  using std::scoped_allocator_adaptor;
  using std::operator==;
}
export namespace std {
  using std::counting_semaphore;
  using std::binary_semaphore;
}
export namespace std {
  using std::set;
  using std::operator==;
  using std::operator<=>;
  using std::swap;
  using std::erase_if;
  using std::multiset;
  namespace pmr {
    using std::pmr::multiset;
    using std::pmr::set;
  }
}
export namespace std {
  using std::shared_mutex;
  using std::shared_timed_mutex;
  using std::shared_lock;
  using std::swap;
}
export namespace std {
  using std::source_location;
}
export namespace std {
  using std::dynamic_extent;
  using std::span;
  namespace ranges {
    using std::ranges::enable_borrowed_range;
    using std::ranges::enable_view;
  }
  using std::as_bytes;
  using std::as_writable_bytes;
}
export namespace std {
}
export namespace std {
  using std::basic_stringbuf;
  using std::swap;
  using std::stringbuf;
  using std::wstringbuf;
  using std::basic_istringstream;
  using std::istringstream;
  using std::wistringstream;
  using std::basic_ostringstream;
  using std::ostringstream;
  using std::wostringstream;
  using std::basic_stringstream;
  using std::stringstream;
  using std::wstringstream;
}
export namespace std {
  using std::stack;
  using std::operator==;
  using std::operator!=;
  using std::operator<;
  using std::operator>;
  using std::operator<=;
  using std::operator>=;
  using std::operator<=>;
  using std::swap;
  using std::uses_allocator;
}
export namespace std {
}
export namespace std {
  using std::domain_error;
  using std::invalid_argument;
  using std::length_error;
  using std::logic_error;
  using std::out_of_range;
  using std::overflow_error;
  using std::range_error;
  using std::runtime_error;
  using std::underflow_error;
}
export namespace std {
}
export namespace std {
  using std::stop_token;
  using std::stop_source;
  using std::nostopstate;
  using std::nostopstate_t;
  using std::stop_callback;
}
export namespace std {
  using std::basic_streambuf;
  using std::streambuf;
  using std::wstreambuf;
}
export namespace std {
  using std::char_traits;
  using std::basic_string;
  using std::operator+;
  using std::operator==;
  using std::operator<=>;
  using std::swap;
  using std::operator>>;
  using std::operator<<;
  using std::getline;
  using std::erase;
  using std::erase_if;
  using std::string;
  using std::u16string;
  using std::u32string;
  using std::u8string;
  using std::wstring;
  using std::stod;
  using std::stof;
  using std::stoi;
  using std::stol;
  using std::stold;
  using std::stoll;
  using std::stoul;
  using std::stoull;
  using std::to_string;
  using std::to_wstring;
  namespace pmr {
    using std::pmr::basic_string;
    using std::pmr::string;
    using std::pmr::u16string;
    using std::pmr::u32string;
    using std::pmr::u8string;
    using std::pmr::wstring;
  }
  using std::hash;
  inline namespace literals {
    inline namespace string_literals {
      using std::literals::string_literals::operator""s;
    }
  }
}
export namespace std {
  using std::basic_string_view;
  namespace ranges {
    using std::ranges::enable_borrowed_range;
    using std::ranges::enable_view;
  }
  using std::operator==;
  using std::operator<=>;
  using std::operator<<;
  using std::string_view;
  using std::u16string_view;
  using std::u32string_view;
  using std::u8string_view;
  using std::wstring_view;
  using std::hash;
  inline namespace literals {
    inline namespace string_view_literals {
      using std::literals::string_view_literals::operator""sv;
    }
  }
}
export namespace std {
}
export namespace std {
}
export namespace std {
  using std::error_category;
  using std::generic_category;
  using std::system_category;
  using std::error_code;
  using std::error_condition;
  using std::system_error;
  using std::is_error_code_enum;
  using std::is_error_condition_enum;
  using std::errc;
  using std::make_error_code;
  using std::operator<<;
  using std::make_error_condition;
  using std::operator==;
  using std::operator<=>;
  using std::hash;
  using std::is_error_code_enum_v;
  using std::is_error_condition_enum_v;
}
export namespace std {
}
export namespace std {
  using std::thread;
  using std::swap;
  using std::jthread;
  namespace this_thread {
    using std::this_thread::get_id;
    using std::this_thread::sleep_for;
    using std::this_thread::sleep_until;
    using std::this_thread::yield;
  }
  using std::operator==;
  using std::operator<=>;
  using std::operator<<;
  using std::formatter;
  using std::hash;
}
export namespace std {
  using std::tuple;
  using std::basic_common_reference;
  using std::common_type;
  using std::ignore;
  using std::forward_as_tuple;
  using std::make_tuple;
  using std::tie;
  using std::tuple_cat;
  using std::apply;
  using std::make_from_tuple;
  using std::tuple_element;
  using std::tuple_size;
  using std::get;
  using std::tuple_element_t;
  using std::operator==;
  using std::operator<=>;
  using std::uses_allocator;
  using std::swap;
  using std::tuple_size_v;
}
export namespace std {
  using std::integral_constant;
  using std::bool_constant;
  using std::false_type;
  using std::true_type;
  using std::is_array;
  using std::is_class;
  using std::is_enum;
  using std::is_floating_point;
  using std::is_function;
  using std::is_integral;
  using std::is_lvalue_reference;
  using std::is_member_function_pointer;
  using std::is_member_object_pointer;
  using std::is_null_pointer;
  using std::is_pointer;
  using std::is_rvalue_reference;
  using std::is_union;
  using std::is_void;
  using std::is_arithmetic;
  using std::is_compound;
  using std::is_fundamental;
  using std::is_member_pointer;
  using std::is_object;
  using std::is_reference;
  using std::is_scalar;
  using std::is_abstract;
  using std::is_aggregate;
  using std::is_const;
  using std::is_empty;
  using std::is_final;
  using std::is_polymorphic;
  using std::is_standard_layout;
  using std::is_trivial;
  using std::is_trivially_copyable;
  using std::is_volatile;
  using std::is_bounded_array;
  using std::is_scoped_enum;
  using std::is_signed;
  using std::is_unbounded_array;
  using std::is_unsigned;
  using std::is_constructible;
  using std::is_copy_constructible;
  using std::is_default_constructible;
  using std::is_move_constructible;
  using std::is_assignable;
  using std::is_copy_assignable;
  using std::is_move_assignable;
  using std::is_swappable;
  using std::is_swappable_with;
  using std::is_destructible;
  using std::is_trivially_constructible;
  using std::is_trivially_copy_constructible;
  using std::is_trivially_default_constructible;
  using std::is_trivially_move_constructible;
  using std::is_trivially_assignable;
  using std::is_trivially_copy_assignable;
  using std::is_trivially_destructible;
  using std::is_trivially_move_assignable;
  using std::is_nothrow_constructible;
  using std::is_nothrow_copy_constructible;
  using std::is_nothrow_default_constructible;
  using std::is_nothrow_move_constructible;
  using std::is_nothrow_assignable;
  using std::is_nothrow_copy_assignable;
  using std::is_nothrow_move_assignable;
  using std::is_nothrow_swappable;
  using std::is_nothrow_swappable_with;
  using std::is_nothrow_destructible;
  using std::is_implicit_lifetime;
  using std::has_virtual_destructor;
  using std::has_unique_object_representations;
  using std::alignment_of;
  using std::extent;
  using std::rank;
  using std::is_base_of;
  using std::is_virtual_base_of;
  using std::is_convertible;
  using std::is_nothrow_convertible;
  using std::is_same;
  using std::is_invocable;
  using std::is_invocable_r;
  using std::is_nothrow_invocable;
  using std::is_nothrow_invocable_r;
  using std::add_const;
  using std::add_cv;
  using std::add_volatile;
  using std::remove_const;
  using std::remove_cv;
  using std::remove_volatile;
  using std::add_const_t;
  using std::add_cv_t;
  using std::add_volatile_t;
  using std::remove_const_t;
  using std::remove_cv_t;
  using std::remove_volatile_t;
  using std::add_lvalue_reference;
  using std::add_rvalue_reference;
  using std::remove_reference;
  using std::add_lvalue_reference_t;
  using std::add_rvalue_reference_t;
  using std::remove_reference_t;
  using std::make_signed;
  using std::make_unsigned;
  using std::make_signed_t;
  using std::make_unsigned_t;
  using std::remove_all_extents;
  using std::remove_extent;
  using std::remove_all_extents_t;
  using std::remove_extent_t;
  using std::add_pointer;
  using std::remove_pointer;
  using std::add_pointer_t;
  using std::remove_pointer_t;
  using std::basic_common_reference;
  using std::common_reference;
  using std::common_type;
  using std::conditional;
  using std::decay;
  using std::enable_if;
  using std::invoke_result;
  using std::remove_cvref;
  using std::type_identity;
  using std::underlying_type;
  using std::unwrap_ref_decay;
  using std::unwrap_reference;
  using std::common_reference_t;
  using std::common_type_t;
  using std::conditional_t;
  using std::decay_t;
  using std::enable_if_t;
  using std::invoke_result_t;
  using std::remove_cvref_t;
  using std::type_identity_t;
  using std::underlying_type_t;
  using std::unwrap_ref_decay_t;
  using std::unwrap_reference_t;
  using std::void_t;
  using std::conjunction;
  using std::disjunction;
  using std::negation;
  using std::is_array_v;
  using std::is_class_v;
  using std::is_enum_v;
  using std::is_floating_point_v;
  using std::is_function_v;
  using std::is_integral_v;
  using std::is_lvalue_reference_v;
  using std::is_member_function_pointer_v;
  using std::is_member_object_pointer_v;
  using std::is_null_pointer_v;
  using std::is_pointer_v;
  using std::is_rvalue_reference_v;
  using std::is_union_v;
  using std::is_void_v;
  using std::is_arithmetic_v;
  using std::is_compound_v;
  using std::is_fundamental_v;
  using std::is_member_pointer_v;
  using std::is_object_v;
  using std::is_reference_v;
  using std::is_scalar_v;
  using std::has_unique_object_representations_v;
  using std::has_virtual_destructor_v;
  using std::is_abstract_v;
  using std::is_aggregate_v;
  using std::is_assignable_v;
  using std::is_bounded_array_v;
  using std::is_const_v;
  using std::is_constructible_v;
  using std::is_copy_assignable_v;
  using std::is_copy_constructible_v;
  using std::is_default_constructible_v;
  using std::is_destructible_v;
  using std::is_empty_v;
  using std::is_final_v;
  using std::is_implicit_lifetime_v;
  using std::is_move_assignable_v;
  using std::is_move_constructible_v;
  using std::is_nothrow_assignable_v;
  using std::is_nothrow_constructible_v;
  using std::is_nothrow_copy_assignable_v;
  using std::is_nothrow_copy_constructible_v;
  using std::is_nothrow_default_constructible_v;
  using std::is_nothrow_destructible_v;
  using std::is_nothrow_move_assignable_v;
  using std::is_nothrow_move_constructible_v;
  using std::is_nothrow_swappable_v;
  using std::is_nothrow_swappable_with_v;
  using std::is_polymorphic_v;
  using std::is_scoped_enum_v;
  using std::is_signed_v;
  using std::is_standard_layout_v;
  using std::is_swappable_v;
  using std::is_swappable_with_v;
  using std::is_trivial_v;
  using std::is_trivially_assignable_v;
  using std::is_trivially_constructible_v;
  using std::is_trivially_copy_assignable_v;
  using std::is_trivially_copy_constructible_v;
  using std::is_trivially_copyable_v;
  using std::is_trivially_default_constructible_v;
  using std::is_trivially_destructible_v;
  using std::is_trivially_move_assignable_v;
  using std::is_trivially_move_constructible_v;
  using std::is_unbounded_array_v;
  using std::is_unsigned_v;
  using std::is_volatile_v;
  using std::alignment_of_v;
  using std::extent_v;
  using std::rank_v;
  using std::is_base_of_v;
  using std::is_virtual_base_of_v;
  using std::is_convertible_v;
  using std::is_invocable_r_v;
  using std::is_invocable_v;
  using std::is_nothrow_convertible_v;
  using std::is_nothrow_invocable_r_v;
  using std::is_nothrow_invocable_v;
  using std::is_same_v;
  using std::conjunction_v;
  using std::disjunction_v;
  using std::negation_v;
  using std::is_constant_evaluated;
  using std::aligned_storage;
  using std::aligned_storage_t;
  using std::aligned_union;
  using std::aligned_union_t;
  using std::is_pod;
  using std::is_pod_v;
}
export namespace std {
  using std::hash;
  using std::type_index;
}
export namespace std {
  using std::bad_cast;
  using std::bad_typeid;
  using std::type_info;
}
export namespace std {
  using std::unordered_map;
  using std::unordered_multimap;
  using std::operator==;
  using std::swap;
  using std::erase_if;
  namespace pmr {
    using std::pmr::unordered_map;
    using std::pmr::unordered_multimap;
  }
}
export namespace std {
  using std::unordered_set;
  using std::unordered_multiset;
  using std::operator==;
  using std::swap;
  using std::erase_if;
  namespace pmr {
    using std::pmr::unordered_multiset;
    using std::pmr::unordered_set;
  }
}
export namespace std {
  using std::swap;
  using std::exchange;
  using std::forward;
  using std::forward_like;
  using std::move;
  using std::move_if_noexcept;
  using std::as_const;
  using std::declval;
  using std::cmp_equal;
  using std::cmp_not_equal;
  using std::cmp_greater;
  using std::cmp_greater_equal;
  using std::cmp_less;
  using std::cmp_less_equal;
  using std::in_range;
  using std::to_underlying;
  using std::unreachable;
  using std::index_sequence;
  using std::integer_sequence;
  using std::make_index_sequence;
  using std::make_integer_sequence;
  using std::index_sequence_for;
  using std::pair;
  using std::basic_common_reference;
  using std::common_type;
  using std::operator==;
  using std::operator<=>;
  using std::make_pair;
  using std::tuple_element;
  using std::tuple_size;
  using std::get;
  using std::piecewise_construct;
  using std::piecewise_construct_t;
  using std::in_place;
  using std::in_place_t;
  using std::in_place_type;
  using std::in_place_type_t;
  using std::in_place_index;
  using std::in_place_index_t;
  namespace rel_ops {
    using rel_ops::operator!=;
    using rel_ops::operator>;
    using rel_ops::operator<=;
    using rel_ops::operator>=;
  }
}
export namespace std {
  using std::gslice;
  using std::gslice_array;
  using std::indirect_array;
  using std::mask_array;
  using std::slice;
  using std::slice_array;
  using std::valarray;
  using std::swap;
  using std::operator*;
  using std::operator/;
  using std::operator%;
  using std::operator+;
  using std::operator-;
  using std::operator^;
  using std::operator&;
  using std::operator|;
  using std::operator<<;
  using std::operator>>;
  using std::operator&&;
  using std::operator||;
  using std::operator==;
  using std::operator!=;
  using std::operator<;
  using std::operator>;
  using std::operator<=;
  using std::operator>=;
  using std::abs;
  using std::acos;
  using std::asin;
  using std::atan;
  using std::atan2;
  using std::cos;
  using std::cosh;
  using std::exp;
  using std::log;
  using std::log10;
  using std::pow;
  using std::sin;
  using std::sinh;
  using std::sqrt;
  using std::tan;
  using std::tanh;
  using std::begin;
  using std::end;
}
export namespace std {
  using std::variant;
  using std::variant_alternative;
  using std::variant_npos;
  using std::variant_size;
  using std::variant_size_v;
  using std::get;
  using std::get_if;
  using std::holds_alternative;
  using std::variant_alternative_t;
  using std::operator==;
  using std::operator!=;
  using std::operator<;
  using std::operator>;
  using std::operator<=;
  using std::operator>=;
  using std::operator<=>;
  using std::visit;
  using std::monostate;
  using std::swap;
  using std::bad_variant_access;
  using std::hash;
}
export namespace std {
  using std::vector;
  using std::operator==;
  using std::operator<=>;
  using std::swap;
  using std::erase;
  using std::erase_if;
  namespace pmr {
    using std::pmr::vector;
  }
  using std::hash;
  using std::formatter;
}
export namespace std {
}